<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">

<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->


<head>
    <title>Iss2023-LLA-Sprint 0</title>
    <link href="defaultStyle.css" rel="stylesheet">
	<link  href="menuCss.css" rel="stylesheet">
</head>


<body>
<div id="top">
<h1>Progetto Finale ISS - Waste Service</h1>
</div>
<div class="remark">
<nav>
    <ul>
        <li><a href="./Sprint0-LLA.html">sprint0</a></li>
        <li><a href="./Sprint1-LLA.html">sprint1</a></li>
    </ul>
</nav>
</div>
<div class="body">
<h2>Introduction</h2>
<div class="remark">
<p>Progetto finale di ISS che consiste nel realizzare un sistema di gestione dei rifiuti in cui un robot svolge il compito di trasportare i materiali dal camion ai relativi contenitori di smistamento. Attualmente, ci concentriamo su una fase preliminare di analisi dei requisiti, che consiste nel comprendere le esigenze del cliente e tradurle in una forma formalizzata e strutturata.</p>

</div>

<h2>Requirements</h2>
<div class="remark">
<p>Si riporta la pagina di requisiti del committente: <a target="_blank" href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/TemaFinale22.html">Waste Service 22.pdf</a></p>
</div>

<!----------------------- REQUIREMENT ANALYSIS --------------------------->

<h2>QActor Metalanguage (QAK)</h2>
<div class="remark">
    <p> Nella seguente analisi dei requisiti è risultato necessario l'utilizzo di un modello di formalizzazione che permettesse la definizione di eventi, sintassi a scambio di messaggi e architetture a componenti distribuiti. </p>
    <p> Si farà riferimento al linguaggio e metamodello QAK, basato sul paradigma ad attori, per realizzare e definire il modello dell'architettura secondo le esigenze d'isolamento dei componenti, sfruttando i vantaggi dell'interazioni asincrone a scambio di messaggi
        in quanto i linguaggi popolari come Java o simili non consentono l'astrazione di questi concetti in maniera semplice e intuitiva.</p>
    <p>Il <r>QAK</r> permette la definizione in poche semplici istruzioni di attori come macchine a stati finiti che interagiscono secondo semantiche a scambio di messaggi.</p>

    <n>In allegato la documentazione che lo riguarda <a target="_blank" href="./QAK.html">QAK-Document</a></n>
    <br>
    <n>Legenda delle figure: <a href="img/Legenda.png">Legenda.png</a></n>
</div>
<A NAME="Requirements"></A>

<h2>Analisi dei Requisiti</h2>
    <h3>Componenti del sistema</h3>
    <div class="remark">
        <p>Nei requisiti si evidenziano sette componenti principali:</p>
        <ul>
            <li><b>WasteService</b></li>
<!--            <li><b>DDR Robot</b></li>-->
            <li><b>Transport Trolley</b></li>
            <li><b>WasteServiceStatusGUI</b></li>
            <li><b>Sonar</b></li>
            <li><b>Led</b></li>
<!--            <li><b>SmartDevice</b></li>-->
        </ul>

        <p>Il documento dei requisiti evidenzia anche alcuni dispositivi fisici del sistema:</p>
        <ul>
            <li><b>Raspberry</b>: contesto esterno sul quale sono montati <b>Led</b> e <b>Sonar</b></li>
            <li><b>DDR Robot</b></li>
            <li><b>Waste Truck</b></li>
            <li><b>Smart Device</b></li>
        </ul>

        <h4>Modello Architetturale dei requisiti</h4>
        <img src="img/General_Architecture_0.png" alt="General Architecture">
    </div>

<h3>Definizione delle variabili del sistema</h3>
    <div class="remark">
		<h4>Service Area (<r2>SA</r2>)</h4>
        <p>Area rettangolare priva di ostacoli, che viene formalizzata con la definizione di un rettangolo.</p>
        <p>Nella <r>Service Area</r> si identificano 4 posizioni:</p> <!--: Indoor, PlasitcBox, GlassBlox e Home.</p> -->
        <ul>
            <li>Indoor</li>
            <li>Plastic Box</li>
            <li>Glass Box</li>
            <li>Home</li>
        </ul>
        <p>Le misure della <r>ServiceArea</r> si suppongono note, in quanto il committente specifica la possibilità di misurazione della stanza.</p>
        <p>Dunque nel seguente documento si farà riferimento alle misure della stanza come note denominandole "X" e "Y", rispettivamente per il lato orizzontale e verticale della <r>SA</r>.</p>
        <p class="remark">Nel caso comunque non fosse possibile reperire le misure sarà possibile utilizzare il Software fornito dalla nostra <i>Software House</i> per la misurazione della stanza con l'utilizzo del solo <r>DDR Robot</r>.</p>
        <p>Si riporta il riferimento al documento del progetto: <a target="_blank" href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/Applicazioni22.html#id4">unibo.mapperQak22</a>.</p>
        <pre><code>
    Rectangle (x, y)
        x: Lunghezza
        y: Altezza
        </code></pre>
        <pre><code>
    Enum Position = {Indoor, PlasticBox, GlassBox, Home}
        </code></pre>
        <img src="./img/Rettangolo-ServiceArea3.png" style="width: 30%" alt="ServiceArea Rectangle (x,y)">

        <br>
        <br>

    <!------------------------ ------------------------>
        <h4>MaxGB, MaxPB</h4>
        <p><i>MaxGB</i> è la capacità massima relativa al GlassBox.</p>
        <p><i>MaxPB</i> è la capacità massima relativa al PlasticBox.</p>

        <p>Entrambe formalizzate come segue:</p>
        <pre><code>
    val MAXGB : Float
        </code></pre>
        <pre><code>
    val MAXPB : Float
        </code></pre>

        <p>Per il monitoraggio della capienza corrente formalizziamo le seguenti variabili:</p>
        <pre><code>
    var contGB : Float
        </code></pre>
        <pre><code>
    var contPB : Float
        </code></pre>

        <br>


        <!------------------------ ------------------------>
        <h4>Gestione tempo di raccolta/deposito del materiale dal truck</h4>
        <p>Il commitente precisa che il tempo di raccolta del materiale del truck è sempre limitato e prevedibile,
            mentre il tempo necessario per il deposito potrebbe essere anche alquanto lungo.</p>
        <p>Significa che:</p>
        <ul>
            <li>Avremo un <code><i>PickingTime</i></code> definito</li>
            <pre><code>var pickingTime : int (seconds)</code></pre>
        </ul>
        <n> Potrà essere usato per gestire il reinvio di richieste da parte dello SmartDevice allo scadere di un Timeout.<br>
            Per quanto riguarda invece lo scarico, avendo un modello a scambio di messaggi con interazioni ad eventi non risulta un problema.
        </n>


        <!------------------------ ------------------------>



        <h3>Deposit Action</h3>
        <p>La <r>Deposit Action</r> è definita come una sequenza di posizioni in cui il <r>DDR</r> deve deve raggiungere:</p>
        <ol>
            <li>Indoor</li>
            <li>PlasticBox/GlassBox</li>
            <li>Home</li>
        </ol>

        <p>La <r>Deposit Action</r> può essere dunque definita come una sequenza di percorsi effettuati dal <r>DDR</r>.</p>
        <p>Da requisiti va considerato inoltre che il <i>WasteService</i> potrebbe ricevere un nuova richiesta mentre sta ancora eseguendo la <r>Deposit Action</r> precedente e che il truck va liberato nel minor tempo possibile,
            dunque il percorso è definito come segue.</p>
        <ul>
            <li>Home/PB/GB -> Indoor</li>
            <li>Indoor -> PlasticBox/GlassBox</li>
            <li>PlasticBox/GlassBox -> Indoor/Home</li>
        </ul>

        <pre><code>
    Enum TTRoutes = {HI, IP, IG, PH, GH, <r>PI, GI</r>}
        </code></pre>
        <img src="img/ServiceAreaPosition-Routes2.png" alt="">

        <p>Date le seguenti ulteriori informazioni:</p>
        <ul>
            <li><r>Service Aera</r> è rettangolare e priva di ostacoli</li>
            <li>Il <r>DDR Robot</r> è dotato di un sonar on-board utilizzabile per le collisioni</li>
            <li>Il Software per il movimento del nostro <r>DDR Robot</r> permette la rotazione di 90°</li>
        </ul>
        <p>Il percorso ottimale utilizzabile è quello fatto percorrendo il perimetro della stanza, dunque si riporta la sua formalizzazione:</p>

        <pre><code>
    Enum TTRoutes = {HI, IP, PI, PH, PG, GP, GH}
        </code></pre>
        <img src="img/ServiceAreaPosition-Routes3.png" alt="">
    </div>



<h3>Definizione delle componenti del sistema</h3>
    <div class="remark">
    <!------------------------ ------------------------>
        <h4>DDR Robot</h4>
        <p>Con <r>DDR Robot</r> si intende <i>Differential Drive Robot</i> la cui documentazione è disponibile nel documento seguente, fornito dalla nostra <i>Software House</i>: <a target="_blank" href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/VirtualRobot.html#differential-drive-robot">Differential Drive Robot</a></p>
        <p>Non avendo a disposizione un <r>DDR Robot</r> fisico e considerando i tempi, i costi di realizzazione del robot e la necessità di effettuare test
            del <i>Software</i>, viene messo a disposizione, dalla nostra <i>Software House</i>, un simulatore virtuale del <r>DDR Robot</r>: il <i><a target="_blank" href="http://htmlpreview.github.io/?https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/userDocs/wenv.html">"Wenv22-VirtualRobot</a></i>.</p>
        <p>Questo simula in ambiente virtuale, le caratteristiche principali e i comportamenti del <r>DDR</r> permettendo il testing e la simulazione della nostra architettura come su un <r>DDR</r> fisico.</p>
        <p>Essendo il <i><b>Wenv22</b></i> un simulatore di un <r>DDR</r> fisico, anche nelle sue interazioni, d'ora in poi ci riferiremo semplicemente
            al <r>DDR</r> senza specificare se <i>Simulato</i> o <i>Fisico</i>, in quanto l'interazione non cambia.</p>


        <p>Il <r>DDR</r> verrà dunque inteso come un <u>componente fisico del sistema con il quale la nostra architettura <i>Software</i> interagirà</u>.</p>
        <p>Facendo riferimento ai componenti implemntati nella nostra <i>Software House</i>, la gestione del <r>DDR</r> potrà avvenire attraverso il componente <c><a target="_blank" href="https://github.com/anatali/issLab2022/tree/main/unibo.basicrobot22">BasicRobot22</a></c>.</p>
        <p>Dunque nella nostra archietettura inseriremo il componente <c>BasicRobot22</c> con il quale interagiremo per il controllo del <r>DDR</r>.</p>


        <h4>BasicRobot22</h4>
        <p>Definiamo in breve il <c><a target="_blank" href="https://github.com/anatali/issLab2022/tree/main/unibo.basicrobot22">BasicRobot22</a></c>:</p>
        <ul>
            <li>Esegue comandi-base di spostamento, con argomento:<pre><code> MOVE = w | s | l | r | h </code></pre> </li>
            <li>Permette l'esecuzione di <i>step</i>, rispondendo con <b>stepdone</b> o <b>stepfail</b></li>
            <li>È in grado di utilizzare diversi tipi di robot (virtuali e reali) costruiti ciascuno con una propria tecnologia</li>
            <li>È in grado di percepire e gestire informazioni provenienti dall’ambiente</li>
        </ul>
        <img src="./img/basicrobot22-image0.png" alt="basicrobot22" style="width: 250px">
        <p>Nel seguente file la documentazione completa: <c><a target="_blank" href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/BasicRobot22.html">BasicRobot22</a></c>.
        E un suo modello eseguibile <a href="https://github.com/anatali/issLab2022/blob/main/unibo.basicrobot22/src/basicrobot.qak">basicrobot.qak</a></p>

        <!------------------------ ------------------------>

        <h4>Gestione delle collisioni</h4>
            <p>La gestione delle collisioni avviene attraverso un <i><b><u>sonar on-board</u></b></i> presente sul DDR.</p>
            <p>Significa che il DDR sarà predisposto di un rarar frontale e utilizzabile rilevare ostacoli/muri davanti a lui.</p>
            <n>Il nostro software <c>BasicRobot22</c> già presuppone la presenza di un <i>sonar on-board</i> e gestisce le collisioni.</n>


        <!------------------------ ------------------------>





<h3>Transport Trolley (<r2>TT</r2>)</h3>
    <p>Il <r>TransportTrolley</r> è l'entità <i>Software</i> si occupa di controllare e far eseguire la <r>Deposit Action</r> al <r>DDR</r> inviandogli i comandi di movimento.</p>

    <p>Fisicamente è formalizzato come un quadrato di dimensione RD.</p>
        <pre><code>
    val RD : float
        </code></pre>
        <pre><code>
    Square: (l*l)
        l= RD
        </code></pre>
        <img src="./img/Quadrato-TransportTrolley.png" alt="Quadrato di lato RD" style="width: 15%">

    <h4>Formalizzazione a stati finiti</h4>
        <p>La sua formalizzazione <i>Software</i> può essere rappresentata come un automa a stati finiti, definito come segue tramite il linguaggio QAK:</p>

<pre><code>
QActor transporttrolley context ctxwasteservice {
	State s0 initial{
	    ...
	} Goto waiting

	State waiting {
	    ...
	} Transition t0 whenRequest pickupReq -> pickup

	State pickup {
            ...
	} Goto depositPlastic if[# materialType == "plastic" #] else depositGlass

	State depositPlastic {
            ...
	} Goto goHome

	State depositGlass {
            ...
	} Goto goHome

	State goHome {
            ...
	} Goto waiting
}
</code></pre>

        <tt>Visto il requisito riguardante la possibilità di gestione di richieste anche durante l'esecuzione di un deposito e il voler liberare il camion il prima possibile, si evidenziano le seguenti transazioni necessarie:
        </tt>
        <img src="./img/TransportTrolley.png" alt="TransportTrolleyModelDiagram" style="width: 220px">

        <!------------------------ ------------------------>

<h3>WasteTruck</h3>
        <p> Entità che si presenta in INDOOR e richiede lo scarico del materiale che trasporta attraverso l’uso di uno
            <r>Smart Device</r>, ovvero l'entità sofwtare che si occupa della sua interazione con il sistema.</p>
        <p>Il <r>Waste Truck</r> è un entità esterna al sistema ma che interagisce con il nostro <r>WasteService</r> per lo scarico dei rifiuti.</p>
        <p>Lo <r>Smart Device</r> non va implementato, ma l'interazione tra lo <r>Smart Device</r> e il <r>WasteService</r> è fondamentale per i requisiti forniti, per cui:</p>
        <ul>
            <li>Si formalizza l'interazione con una interazione Request/Response</li>
            <li>Il <r>Waste Truck</r> richiederà lo scarico di rifiuti tramite una <r>DepositRequest</r></li>
            <li>Lo <i>Smart Device</i> verrà rappresentato e simulato con un attore che invia richieste al <r>WS</r></li>
        </ul>

        <!------------------------ ------------------------>

        <h3>WasteTruckRequest</h3>

        <p>Il <r>WasteService</r> e il <r>WasteTruck</r> sono in comunicazione tramite lo <r>Smart Device</r>.
            Lo <r>Smart Device</r> effettuerà una <i>request</i> (<r>DepositRequest</r>) di deposito di materiale specificando il tipo di materiale e attenderà la risposta del <b>WasteService</b>.</p>
        <ul>
            <li><code>loadaccepted</code>: richiesta accettata (quando è possibile gestirla/capacità Box non piena)</li>
            <li><code>loadrejecetd</code>: richiesta rifiutata (quando non è possibile gestirla/capacità Box piena)</li>
        </ul>

    <p>Formalizziamo l'interazione con i seguenti messaggi:</p>
        <pre><code>
	Request depositRequest	: 	depositRequest(ID, TYPE, TRUCKLOAD)
	Reply loadaccept	: 	loadaccept(ID)
	Reply loadrejecetd	: 	loadrejecetd(ID)
	</code></pre>
    <pre><code>
        var ID          : String
        var TRUCKLOAD   : float

        enum TYPE = {"plastic", "glass"}
    </code></pre>
        <p>Spiegazione di ciascun messaggio:</p>
        <ul>
            <li>Request <code>depositRequest</code>: comando che indica la richiesta di un deposito di rifiuti. I parametri inclusi nella richiesta sono l'ID del deposito, il tipo di rifiuti e il carico del camion.</li>
            <li>Reply <code>loadaccept</code>: risposta positiva alla richiesta di deposito dei rifiuti. L'ID incluso nella risposta corrisponde all'ID della richiesta di deposito.</li>
            <li>Reply <code>loadrejecetd</code>: risposta negativa alla richiesta di deposito dei rifiuti. L'ID incluso nella risposta corrisponde all'ID della richiesta di deposito.</li>
        </ul>
        <p>Il parametro <code>ID</code> è stato inserito per poter gestire richieste duplicate ed eventuali errori, rendendo più robusto il sistema</p>
        <tt>Il committente ha specificato che sarebbe meglio mandare via il truck il prima possibile, per questo motivo
            va confermato il pickup del trolley allo <r>Smart Device</r> non appena il <r>DDR</r> ha terminato lo scarico.</tt>
        <p>Non essendo specificati altri comportamenti per il <r>Waste Truck</r> non risulta necessario l'invio di entrambi i messaggi <code>loadaccept</code> e <code>pickupOk</code>. La formalizzazione dei messaggi e dell'interazione Request/Response evolve come segue:</p>
        <p>Viene modificato il significato della <code>loadaccept</code> come segue:</p>
        <ul><li>La <code>loadaccept</code> verrà inviata direttamente al completamento dello scarico dei rifiuti da parte del <r>DDR</r> svincolando direttamente il <r>Waste Truck</r></li></ul>
        <p>Ciò aggiunge inoltre il vantaggio alla nostra architettura di non aver bisogno che il <r>WasteService</r> conosca il contesto dello <r>SmartDevice</r> in quanto dovrà solo effettuare una reply alle richieste.</p>



        <h4>Formalizzazione a stati finiti (QAK)</h4>
        <p>Si introducono dunque due componenti <i>Software</i>:</p>
        <ul>
            <li>Il <code>WasteService</code>: attore che gestisce le richieste in entrata al sistema dallo <r>Smart Device</r></li>
            <li>Lo <code>SmartDevice</code>: attore che simula l'interazione dello <r>Smart Device</r> con il nostro <code>WasteService</code></li>
        </ul>


        <h5>WasteService</h5>
        <pre><code>
QActor wasteservice context ctxwasteservice{
	State s0 initial {
		...
	} Goto waiting

	State waiting{
		...
	} Transition t0 whenRequest wasteDeposit -> requestHandling

	State requestHandling {
		...
	} Goto pickingUp if[# accepted == true #] else requestRejected

	State requestRejected {
		//Si svincola il Truck (reply loadrejecetd)
	} Goto waiting

	State pickingUp {
		//Si chiede il pickup al Transport Trolley
	} Transition t1 whenReply pickupOk -> pickupOk

	State pickupOk {
		//Si svincola il truck (reply loadaccept)
	} Goto waiting
}
</code></pre>
        <p><a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Qak_Models/WasteService.qak"> Metamodello QAK WasteService</a></p>
<!--        <img src="./img/WasteService.png" alt="WasteService Actor" style="width: 350px">-->
        
        
        <h5>Smart Device</h5>
        <p>Lo <r>SmartDevice</r> viene utilizzato dal driver per approcciare all'INDOOR mandando una richiesta per depositare il carico specificando il tipo di materiale e il TruckLoad.
            La richiesta da inviare è stata formalizzata precedentemente nel paragrafo relativo alla <a href=#wasteTruckRequest>WasteTruckRequest</a>.
        <p>Lo <r>SmartDevice</r> è un componente esterno al nostro sistema, ma che per motivi di simulazione e testing verrà rappresentato come un attore.
            Un modo veloce e semplice di simulare il comportamento di un Truck esterno al sistema che interagisce con il nostro <r>WasteService</r>.</p>
        <pre><code>
QActor smartdevice context ctxsmartdevice{
	[# var request_ID = 0 #]
	State s0 initial{
	    <b>...</b>
	} Goto idle

	State idle {
	    <b>...</b>
	} Transition t0 whenTime 10000 -> truckArrived

	State truckArrived {
	    <b>...</b>
	} Transition t1 	whenTime  10000 -> truckArrived
				whenReply loadaccept -> waitPickUp
				whenReply loadrejecetd -> truckGoAway

	State waitPickUp {
	    <b>...</b>
	} Transition t2 whenMsg pickupOk -> truckGoAway

	State truckGoAway {
	    <b>...</b>
	} Transition t3 whenTime 3000 -> idle
}
</code></pre>

        <p><a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Qak_Models/SmartDevice.qak"> Metamodello QAK SmartDevice</a></p>
<!--        <img src="img/SmartDevice.png" alt="SmartDevice Actor" style="width: 200px">-->

    <h4>Modello dell'interazione</h4>
        <img src="./img/WasteTruckRequest-V3.2.png" alt="DepositRequest V3.2 - New interaction model">


    <h4>Modellazione <r>Transport Trolley</r></h4>
        <p>Avendo ora introdotto il componente <r>WasteService</r> descriviamo una interazione esemplificativa con il <r>TransportTrolley</r></p>
        <pre><code>
    Request pickupReq : pickupReq(ID, T)	//Richiesta di pickup di un relativo materiale
    Reply pickupOk : pickupOk(ID)		//Risposta di fine pickup, relativa ad una richiesta
        </code></pre>
        <img src="./img/WasteService_TransportTrolley_Int.png" alt="WasteService interaction with TransportTrolley">
        <p>A seguire il riferimento al metamodello eseguibile del contesto: <a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/WasteServiceCtx_QAK/src/WasteServiceCtx_v3.3.qak">WasteServiceCtx_v3.3.qak</a></p>

    <h4>Architettura</h4>
        <img src="./img/Logical_Architecture_v2.png" alt="" style="width: 80vw">


    <h4>Modello dell'interazione - Use cases</h4>
        <ul><li>DepositRequest accettata</li></ul>
        <img src="./img/WasteTruckRequest-complete-accept.png" alt="WasteService Interaction. V3.3" style="width: 70vw">
        <br>

        <ul><li>DepositRequest Rifiutata</li></ul>
        <img src="./img/WasteTruckRequest-complete-reject.png" alt="WasteService Interaction. V3.3" style="width: 70vw">

  <!------------------------ ------------------------>

        <h3>Raspberry</h3>
        <p>Il committente specifica la presenza di due compomenti istallate su un nuovo contesto esterno al contesto del <r>WasteService</r>, ovvero un <c>Raspberry</c>.</p>
        <p>Viene quindi definito un nuovo contesto <c>ctxraspbaerry</c> contentente le due componenti specificate dal committente: </p>
        <ul>
            <li>Un <r>Led</r></li>
            <li>Un <r>Sonar</r></li>
        </ul>

        <h3>Led</h3>
        <p>Strumento connesso in output al componente RaspberryPI esterno al <r>DDR Robot</r>.</p>
        <p>Rappresentato nel sistema come l'attore <i>QAK</i> <r>LedActor</r>.</p>
        <p>Entità software che si occuperà di gestire lo stato del <r>Led</r> reagendo ai cambi di stato del <r>TransportTrolley</r>.</p>

        <ul>Individuiamo e definiamo TRE modalità di funzionamento del <b>Led</b> corrispondenti ai 3 stati del <r>TransportTrolley</r>:
            <li><code>LedOff</code> : <code>atHome</code> (Quando la sua posizione è Home)</li>
            <li><code>LedOn</code>: <code>stopped</code> (Quando bloccato dal <b>Sonar</b>)</li>
            <li><code>LedBlink</code>: <code>moving</code> (quando il <r>TT</r> è in movimento, o sta scaricando/caricando materiale)</li>
        </ul>
        <pre><code>
    enum LedState = {LedOff, LedOn, LedBlink};
        </code></pre>
        <pre><code>
    enum robotState = {atHome, moving, Stopped};
        </code></pre>

        <p>Il <r>TransportTrolley</r> emetterà dunque un evento, che verrà ricevuto e gestito dal <r>LedActor</r></p>
        <pre><code>
    Event robotStateEvent : robotStateEvent(STATE)		//STATE : atHome, moving, stopped
        </code></pre>

        <p>Metamodello QAK del <r>LedActor</r>:</p>
	<pre><code>
QActor ledactor context ctxraspberry {
	State s0 initial {
		println("\t $name: Started! $version") color red
	}
	Goto handleRobotStateEvent

	State handleRobotStateEvent {
            ...
            ...
		println("\t $name: Led state- $ledState") color red
	}
	Transition t0 	whenTime 5000 -> handleRobotStateEvent
			whenEvent robotStateEvent -> handleRobotStateEvent

}
	</code></pre>
	
	<p><a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Qak_Models/LedActor.qak"> Metamodello QAK LedActor</a></p><br>
    <img src="img/LedActor.png" alt="Led Actor" style="width: 250px">

    <!------------------------ ------------------------>

        <h3>Sonar</h3>
        <p>Strumento connesso in input al componente RaspberryPI esterno al <r>DDR Robot</r>.</p>

        <p>Il software relativo al sonar è fornito dal committente in <b>unibo.basicrobot22,
            it.unibo.radarSystem22.domain,
            unibo.sonarqak22</b>.</p>
        <p>Un attore emetterà eventi a seconda della distanza rilevata dal sonar e manda comandi al sonar.</p>

<p>Sonar Qak già implementato fornito nel package unibo.actor22.events della directory test del progetto unibo.actor22, riportiamo la classe SonarActor22
che definisce il Sonar come un attore proattivo e reattivo.
<p><a target="_blank" href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/SonarObservable.html#il-sonar-come-attore-che-emette-eventi"> Documentazione SonarActor22</a></p>
<p><a href="https://github.com/anatali/issLab2022/blob/main/unibo.sonarqak22/src/sonarqak22.qak">Metamodello QAK SonarQak22</a></p>
    <!------------------------ ------------------------>

        <h4>DLimit</h4>
        <p> Distanza limite relativa al <r>Sonar</r> espressa in numero decimale.</p>
        <pre><code>
    val DLIMIT	:	Float
        </code></pre>

        <p>Se la distanza corrente misurata dal Sonar è ≤ DLIMT, il robot deve fermarsi. Quando la distanza corrente è > DLIMIT il robot è libero di muoversi.
            Definiamo la costante <b>DLIMIT</b>:</p>

        <ul>Più precisamente, quello che ci si aspetta quando la distanza diventa ≤ DLIMT, è che:
            <li>Se il robot si sta muovendo esso si ferma. Riprenderà il moto solo quando la distanza torna <code>> DLIMIT</code></li>
            <li>Ogni altra operazione del robot deve terminare. Una volta terminata si rimane in attesa finché la
                distanza non ritorna <code>> DLIMIT</code></li>
        </ul>
        <br>

        <img src="img/Raspberry_Architecture.png" alt="Led Actor" style="width: 380px">

    <!------------------------ ------------------------>


        <h3>WasteServiceStatusGUI</h3>
		<br>
        <p>Pannello di controllo che permette al ServiceManager di monitorare:
            <ul>
                <li>La <b>posizione</b> del <r>Transport trolley</r>: intesa come una delle 4 posizione definite nella service Area (home, indoor, plasticBox, glassBox).</li>
        <li>Lo <b>stato</b> del <r>Transport Trolley</r>: ovvero se è in movimento, se è bloccato, se fermo o sta scaricando o caricando.</li>
                <li>Lo stato corrente dei due contenitori <b>PLASTICBOX</b> e <b>GLASSBOX</b>: ovvero il livello di riempimento corrente.</li>
                <li>Lo stato del <b>LED</b>: acceso, spento on in <i>blinking</i></li>
            </ul>
            <pre><code>
    enum class TransportTrolleyState { REST, MOVING, PICKINGUP, DROPPINGOUT, HALT, BLOCKED }
    enum class TTPosition { home, indoor, plasticbox, glassbox}
    var CurrentPB, CurrentGB : float
    enum class LedState { on, off, blink }
            </code></pre>
    </p>

        <p>Il <r>WasteServiceStatusGUI</r> è inteso come un sistema composto da:</p>
        <ul>
            <li>Una <b>Interfaccia Grafica Web</b> che permetta la visualizzazione di tutte queste info.</li>
            <li>Un <b>Attore <i>osservatore</i></b> che osservi le variabili condivise e aggiorni i valori dell'<i>Interfaccia Grafica Web</i> </li>
        </ul>

        <img src="img/WasteServiceGui_Arch.png" alt="WasteServiceGui Architecture image" style="width: 350px">

<br>

    <!------------------------ ------------------------>

    </div>

    <div class="remark">
        <h2>Logical Architecture</h2>
        <img src="img/Logical_Architecture_complete_v2.png" alt="General Logical Architecture">

        <p><a href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Logical_Architecture_QAK/src/Logical_Architecture_Local.qak">Metamodello QAK dell'Architettura Generale</a></p>

	
        <h3>Riepilogo</h3>
        <p>Componenti dell'architettura del sistema:</p>
        <ul>
            <li><c>ctxWasteService</c>: contesto del core del nostro progetto</li>
                <ul>
                    <li><r>WasteService</r>: componente (Attore) Software da sviluppare che riceve le richieste dello <r>SmartDevice</r></li>
                    <li><r>TransportTrolley</r>: componente (Attore) Software da sviluppare che rappresenta e si occupa di comandare il <r>DDR Robot</r>, comunicando con il <r>BasicRobot22</r></r></li>
                </ul>
            <li><r>DDR Robot</r>: Entità fisica o virtuale di un <i>Differential Drive Robot</i></li>
                <ul>
                    <li><r>BasicRobot22</r>: componente (Attore) Software implementato dalla nostra <i>Software House</i> per il comando di un <r>DDR Robot</r> generico</li>
                </ul>
            <li><c>ctxRaspberry</c>: contesto sul Raspberry sul quale sono presenti i due componenti il <i>Led</i> e il <i>Sonar</i></li>
                <ul>
                    <li><r>LedActor</r>: Componente Software, rappresentato come un Attore, per la gestione del <i>Led</i> fisico</li>
                    <li><r>SonarActor22</r>: componente Software per la gestione del Sonar, con un implementazione disponibile nella nostra <i>Software House</i></li>
                </ul>
            <li><r>WasteServiceGui</r>: componente Software da sviluppare che visualizzi e aggiorni un <i>Interfaccia Grafica</i> per la visualizzazione di informazioni sul sistema</li>
            <li><r>SmartDevice</r>: componente esterno al sistema, <u>non da implementare</u>, che permette la comunicazione delle richieste del <r>Waste Truck</r> al <r>WasteService</r>.
                Verrà rappresentato come un Agente Software (Attore) per la simulazione dell'arrivo di <i>richieste di deposito</i> al nostro sistema.</li>
        </ul>
    </div>

<h2>Work Plan</h2>
<div class="remark">
    <p>Il Primo Sprint si occuperà della <i>Core Business Logic</i> dell'applicazione, quindi degli aspetti principali della logica di smistamento e della navigazione verso le aree designate,
        con l'implementazione del <r>WasteService</r> e del <r>TransportTrolley</r></p>
    <p>Successivamente si provvederà ad integrare <r>LedActor</r> e <r>SonarActor</r> del contesto del <c>Raspberry</c>.</p>
    <p>Infine ci si occuperà della <b>WasteServiceStatusGUI</b>.</p>
</div>
<br/><br/> 	
</div>  

    <!-- USEFUL
    <table style="width:100%" border="1">
    <tr>
    <td style="width:50%">
    </td>
    <td></td>
    </tr>
    </table>
    -->

    <br><br>
</div>

<div style="background-color:rgba(86, 56, 253, 0.9); width:100%; height: 28vw; text-align:left; color:white;">
    <p style="text-align: center; font-size: 12pt;">Studenti: Luca Landolfi, Antonio Franzese, Luca De Risi</p>
    <p style="text-align: center; font-size: 12pt;">Email: luca.landolfi3@studio.unibo.it,  antonio.franzese4@studio.unibo.it, luca.derisi@studio.unibo.it;</p>
    <div style="display: block; margin: 0 15vw;">
        <img src="./img/img_luca.png"   style="float: left; width: 19vw; height: 20vw">
        <img src="./img/img_anto.jpg"   style="float: left; width: 19vw; height: 20vw">
        <img src="./img/img_lude.JPG"   style="float: left; width: 22vw; height: 20vw">
    </div>
</div>
</body>
</html>

<!--
            <li>Lo <i>smartdevice</i> è già stato sviluppato (o comunque è parte dei test), le richieste/risposte (<i>depositrequest</i>, <i>loadaccept</i>, <i>loadrejected</i>) sono requisito.</li>
            <li>Il <i>basicrobot</i> è già stato sviluppato, le interazioni con il robot definite in termini di operazioni di message-passing (<i>cmdbase</i>, <i>cmdstep</i>, <i>situated</i>) sono quindi predefinite.</li>
            <li>Il <i>wasteservice</i> è da sviluppare, l'interfaccia che espone verso l'esterno (<i>depositrequest</i>, <i>loadaccept</i>, <i>loadrejected</i>) è requisito, mentre l'interazione verso componenti interni (comandi da mandare al TT e aggiornare la capacità dei contenitori) per il momento non è stata considerata.</li>
            <li>Il <i>transporttrolley</i> è da sviluppare, e sarà oggetto di analisi del prossimo sprint. Inoltre è ancora incerta la collocazione di questo componente (IN QUALE CONTESTO LO COLLOCHIAMO?).</li>
            <li>Il <i>sonar</i> e il <i>led</i> sono da sviluppare: è disponibile software che dovrà essere analizzato prima di essere eventualmente utilizzato/adattato, VALUTARE SE LE INTERAZIONI SONO UN REQUISITO O GI&Agrave SONO IMPLEMENTATE.</li>
            <li>Il <i>wasteservicestatusgui</i> è da analizzare/sviluppare, e sarà oggetto degli sprint successivi (al momento è incerta la collocazione e/o l'esistenza sotto forma di attore del componente). Le interazioni (TUTTE LE INFO PASSATE ALLA GUI) sono da valutare e al momento restano vaghe (SONO REQUISITO?).</li>
        -->