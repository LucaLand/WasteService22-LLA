<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">

<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->


<head>
    <title>Iss2023-LLA-Sprint 0</title>
    <link href="defaultStyle.css" rel="stylesheet">
	<link  href="menuCss.css" rel="stylesheet">
</head>


<body>
<div id="top">
<h1>Progetto Finale ISS - Waste Service</h1>
</div>
<div class="remark">
<nav>
    <ul>
        <li><a href="./Sprint0-LLA.html">sprint0</a></li>
        <li><a href="./Sprint1-LLA.html">sprint1</a></li>
    </ul>
</nav>
</div>
<div class="body">
<h2>Introduction</h2>
<div class="remark">
<p>Progetto finale di ISS che consiste nel realizzare un sistema di gestione dei rifiuti in cui un robot svolge il compito di trasportare i materiali dal camion ai relativi contenitori di smistamento. Attualmente, ci concentriamo su una fase preliminare di analisi dei requisiti, che consiste nel comprendere le esigenze del cliente e tradurle in una forma formalizzata e strutturata.</p>

</div>

<h2>Requirements</h2>
<div class="remark">
<p>Si riporta la pagina di requisiti del committente: <a target="_blank" href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/TemaFinale22.html">Waste Service 22.pdf</a></p>
</div>

<!----------------------- REQUIREMENT ANALYSIS --------------------------->

<h2>QActor Metalanguage (QAK)</h2>
<div class="remark">
    <p> Nella seguente analisi dei requisiti è risultato necessario l'utilizzo di un modello di formalizzazione che permettesse la definizione di eventi, sintassi a scambio di messaggi e architetture a componenti distribuiti. </p>
    <p> Si farà riferimento al linguaggio e metamodello QAK, basato sul paradigma ad attori, per realizzare e definire il modello dell'architettura secondo le esigenze d'isolamento dei componenti, sfruttando i vantaggi dell'interazioni asincrone a scambio di messaggi
        in quanto i linguaggi popolari come Java o simili non consentono l'astrazione di questi concetti in maniera semplice e intuitiva.</p>
    <p>Il <r>QAK</r> permette la definizione in poche semplici istruzioni di attori come macchine a stati finiti che interagiscono secondo semantiche a scambio di messaggi.</p>
    <p>In allegato la documentazione che lo riguarda <a target="_blank" href="./QAK.html">QAK-Document</a></p>
</div>
<A NAME="Requirements"></A>
<h2>Requirement analysis</h2>
    <div class="remark">
		<h3>Service Area (<r2>SA</r2>)</h3>
        <p>Area rettangolare priva di ostacoli, che viene formalizzata con la definizione di un rettangolo.</p>
        <p>Nella <r>Service Area</r> si identificano 4 posizioni:</p> <!--: Indoor, PlasitcBox, GlassBlox e Home.</p> -->
        <ul>
            <li>Indoor</li>
            <li>Plastic Box</li>
            <li>Glass Box</li>
            <li>Home</li>
        </ul>
        <p>Le misure della <r>ServiceArea</r> si suppongono note, in quanto il committente specifica la possibilità di misurazione della stanza.</p>
        <p>Dunque nel seguente documento si farà riferimento alle misure della stanza come note denominandole "X" e "Y", rispettivamente per il lato orizzontale e verticale della <r>SA</r>.</p>
        <p class="remark">Nel caso comunque non fosse possibile reperire le misure sarà possibile utilizzare il Software fornito dalla nostra <i>Software House</i> per la misurazione della stanza con l'utilizzo del solo <r>DDR Robot</r>.</p>
        <p>Si riporta il riferimento al documento del progetto: <a target="_blank" href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/Applicazioni22.html#id4">unibo.mapperQak22</a>.</p>
        <pre><code>
    Rectangle (x, y)
        x: Lunghezza
        y: Altezza
        </code></pre>
        <pre><code>
    Enum Position = {Indoor, PlasticBox, GlassBox, Home}
        </code></pre>
        <img src="./img/Rettangolo-ServiceArea3.png" style="width: 30%" alt="ServiceArea Rectangle (x,y)">

        <br>
        <br>

    <!------------------------ ------------------------>
        <h3>MaxGB, MaxPB</h3>
        <p><i>MaxGB</i> è la capacità massima relativa al GlassBox.</p>
        <p><i>MaxPB</i> è la capacità massima relativa al PlasticBox.</p>

        <p>Entrambe formalizzate come segue:</p>
        <pre><code>
    val MAXGB : Float
        </code></pre>
        <pre><code>
    val MAXPB : Float
        </code></pre>

        <p>Per il monitoraggio della capienza corrente formalizziamo le seguenti variabili:</p>
        <pre><code>
    var contGB : Float
        </code></pre>
        <pre><code>
    var contPB : Float
        </code></pre>

<br>
    <!------------------------ ------------------------>
        <h3>DDR Robot</h3>
        <p>Con <r>DDR Robot</r> si intende <i>Differential Drive Robot</i> la cui documentazione è disponibile nel documento seguente, fornito dalla nostra <i>Software House</i>: <a target="_blank" href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/VirtualRobot.html">VirtualRobot.html</a></p>
        <p>Non avendo a disposizione un <r>DDR Robot</r> fisico e considerando i tempi, i costi di realizzazione del robot e la necessità di effettuare test
            del <i>Software</i>, viene messo a disposizione, dalla nostra <i>Software House</i>, un simulatore virtuale del <r>DDR Robot</r>: il <i><a target="_blank" href="http://htmlpreview.github.io/?https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/userDocs/wenv.html">"Wenv22-VirtualRobot</a></i>.</p>
        <p>Questo simula in ambiente virtuale, le caratteristiche principali e i comportamenti del <r>DDR</r> permettendo il testing e la simulazione della nostra architettura come su un <r>DDR</r> fisico.</p>
        <p>Essendo il <i><b>Wenv22</b></i> un simulatore di un <r>DDR</r> fisico, anche nelle sue interazioni, d'ora in poi ci riferiremo semplicemente
            al <r>DDR</r> senza specificare se <i>Simulato</i> o <i>Fisico</i>, in quanto l'interazione non cambia.</p>

        <p>Il <r>DDR</r> verrà dunque inteso come un <u>componente fisico del sistema con il quale la nostra architettura <i>Software</i> interagirà</u>.</p>
        <p>Facendo riferimento ai componenti implemntati nella nostra <i>Software House</i>, la gestione del <r>DDR</r> potrà avvenire attraverso il componente <c><a target="_blank" href="https://github.com/anatali/issLab2022/tree/main/unibo.basicrobot22">BasicRobot22</a></c>.</p>
        <p>Dunque nella nostra archietettura inseriremo il componente <c>BasicRobot22</c> con il quale interagiremo per il controllo del <r>DDR</r>.</p>
        <h4>BasicRobot22</h4>
        <p>Definiamo in breve il <c>BasicRobot22</c>:</p>
        <ul>
            <li>Esegue comandi-base di spostamento, con argomento:<pre><code> MOVE = w | s | l | r | h </code></pre> </li>
            <li>Permette l'esecuzione di <i>step</i>, rispondendo con <b>stepdone</b> o <b>stepfail</b></li>
            <li>È in grado di utilizzare diversi tipi di robot (virtuali e reali) costruiti ciascuno con una propria tecnologia</li>
            <li>È in grado di percepire e gestire informazioni provenienti dall’ambiente</li>
        </ul>
        <p>Nel seguente file la documentazione completa: <c><a target="_blank" href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/BasicRobot22.html">BasicRobot22</a></c></p>
        <!------------------------ ------------------------>

        <h4>Gestione delle collisioni</h4>
        <p>La gestione delle collisioni avviene attraverso un <i><b><u>sonar on-board</u></b></i> presente sul DDR.</p>
        <p>Significa che il DDR sarà predisposto di un rarard frontale e utilizzabile rilevare ostacoli/muri davanti a lui.</p>
        <n>Il nostro software <c>BasicRobot22</c> già presuppone la presenza di un <i>sonar on-board</i> e gestisce le collisioni.</n>

        <!------------------------ ------------------------>




<h3>Deposit Action</h3>
        <p>La <r>Deposit Action</r> è definita come una sequenza di posizioni in cui il <r>DDR</r> deve deve raggiungere:</p>
        <ol>
            <li>Indoor</li>
            <li>PlasticBox/GlassBox</li>
            <li>Home</li>
        </ol>

        <p>La <r>Deposit Action</r> può essere dunque definita come una sequenza di percorsi effettuati dal <r>DDR</r>:</p>
        <ul>
            <li>Home -> Indoor</li>
            <li>Indoor -> PlasticBox/GlassBox</li>
            <li>PlasticBox/GlassBox -> Home</li>
        </ul>

        <pre><code>
    Enum TTRoutes = {HI, IP, IG, PH, GH}
        </code></pre>
        <img src="img/ServiceAreaPosition-Routes.png" alt="">

        <p>Da requisiti va considerato inoltre che il <i>WasteService</i> potrebbe ricevere un nuova richiesta mentre sta ancora eseguendo la <r>Deposit Action</r> precedente e che il truck va liberato nel minor tempo possibile,
            dunque il percorso può evolvere come segue:</p>
        <ul>
            <li>Home/PB/GB -> Indoor</li>
            <li>Indoor -> PlasticBox/GlassBox</li>
            <li>PlasticBox/GlassBox -> Indoor/Home</li>
        </ul>

        <pre><code>
    Enum TTRoutes = {HI, IP, IG, PH, GH, <r>PI, GI</r>}
        </code></pre>
        <img src="img/ServiceAreaPosition-Routes2.png" alt="">


        <p>Date le seguenti ulteriori informazioni:</p>
        <ul>
            <li><r>Service Aera</r> è rettangolare e priva di ostacoli</li>
            <li>Il <r>DDR Robot</r> è dotato di un sonar on-board utilizzabile per le collisioni</li>
            <li>Il Software per il movimento del nostro <r>DDR Robot</r> permette la rotazione di 90°</li>
        </ul>
        <p>Il percorso ottimale utilizzabile è quello fatto percorrendo il perimetro della stanza, dunque si riporta la sua formalizzazione:</p>

        <pre><code>
    Enum TTRoutes = {HI, IP, PI, PH, PG, GP, GH}
        </code></pre>
        <img src="img/ServiceAreaPosition-Routes3.png" alt="">


        <!------------------------ ------------------------>







<h3>Transport Trolley (<r2>TT</r2>)</h3>
    <p>Il <r>TransportTrolley</r> è l'entità <i>Software</i> si occupa di far eseguire la <r>Deposit Action</r> al <r>DDR</r> inviandogli i comandi di movimento.</p>

    <p>Fisicamente è formalizzato come un quadrato di dimensione RD.</p>
        <pre><code>
    val RD : float
        </code></pre>
        <pre><code>
    Square: (l*l)
        l= RD
        </code></pre>
        <img src="./img/Quadrato-TransportTrolley.png" alt="Quadrato di lato RD" style="width: 15%">

    <p>La sua formalizzazione <i>Software</i> può esssere rappresentata come un automa a stati finiti, definito come segue tramite il linguaggio QAK:</p>
    <h4>Formalizzazione a stati finiti</h4>
	<pre><code>
QActor transporttrolley context ctxwasteservice {
	[#
		val name = "TransportTrolley"
		var materialType = ""	
	#]

	State s0 initial{
	    ...
	}
	Goto waiting

	State waiting {
	    ...
	}
	Transition t0 whenRequest pickupReq -> pickup

	State pickup {
        ...
	}
	Goto depositPlastic if[# materialType == "plastic" #] else depositGlass

	State depositPlastic {
	<b>...</b>
	}
	Goto goHome

	State depositGlass {
        ...
	}
	Goto goHome

	State goHome {
        ...
	}
	Goto waiting

	}
}
	</code></pre>
    <img src="" alt="TransportTrolleyModelDiagram">
	
	<p><a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/other_QAK/transporttrolley_v1.qak"> Metamodello QAK transporttrolley</a></p><br>


        <!------------------------ ------------------------>

<h3>WasteTruck</h3>
        <p> Entità che si presenta in INDOOR e richiede lo scarico del materiale che trasporta attraverso l’uso di uno
            <r>Smart Device</r>.</p>
        <p>E' un entità esterna al sistema ma che interagisce con il nostro <r>WasteService</r> per lo scarico dei rifiuti.</p>
        <p>L'interazione tra il <r>Waste Truck</r> e il <r>WasteService</r> è fondamentale per i requisiti forniti, per cui:</p>
        <ul>
            <li>Si formalizza l'interazione con una interazione Request/Response -> <r>WasteTruckRequest</r></li>
            <li>Si rappresenta il <r>Waste Truck</r> identificandolo con lo <i>SmartDevice</i> con un attore simulato che invia richieste al <r>WS</r></li>
        </ul>

        <!------------------------ ------------------------>

        <h3>WasteTruckRequest</h3>
        <p>WasteTruck sends a <a NAME=#wasteTruckRequest>WasteTruckRequest</a></p>
        <pre><code>
    var wasteTruckRequest: obj{
        wasteType: enum{plastic, glass};
        wasteLoad: float;
    }
        </code></pre>

        Il <r>WasteService</r> e il <r>WasteTruck</r> sono in comunicazione tramite lo <r>Smart Device</r>.
        Lo <r>Smart Device</r> effettuerà una <i>request</i> di deposito di materiale specificando il tipo di materiale e attenderà la risposta del <b>WasteService</b>.<br>
        <ul>
            <li>requestAccepted: richiesta accettata (quando è possibile gestirla/capacità Box non piena)</li>
            <li>requestRejected: richiesta rifiutata (quando non è possibile gestirla/capacità Box piena)</li>
        </ul>

    <p>Formalizziamo l'interazione con i seguenti messaggi:</p>
        <pre><code>
	Request wasteDeposit	: 	wasteDeposit(ID, TYPE, TRUCKLOAD)
	Reply loadaccept	: 	loadaccept(ID)
	Reply loadrejecetd	: 	loadrejecetd(ID)

	Dispatch pickupOk 	: 	pickupOk(ID)
	</code></pre>
        <p>Lista di comandi o messaggi utilizzati nel sistema per gestire la raccolta dei rifiuti. Ecco una breve spiegazione di ciascun comando:</p>
        <ul>
            <li>Request <code>wasteDeposit</code>: comando che indica la richiesta di un deposito di rifiuti. I parametri inclusi nella richiesta sono l'ID del deposito, il tipo di rifiuti e il carico del camion.</li>
            <li>Reply <code>loadaccept</code>: risposta positiva alla richiesta di deposito dei rifiuti. L'ID incluso nella risposta corrisponde all'ID della richiesta di deposito.</li>
            <li>Reply <code>loadrejecetd</code>: risposta negativa alla richiesta di deposito dei rifiuti. L'ID incluso nella risposta corrisponde all'ID della richiesta di deposito.</li>
            <li>Dispatch <code>pickupOk</code>: comando che indica il completamento della raccolta dei rifiuti dal <r>Waste Truck</r>. L'ID incluso nella risposta corrisponde all'ID del deposito da cui i rifiuti sono stati prelevati.</li>
        </ul>
        <p>Il parametro <code>ID</code> è stato inserito per poter gestire richieste duplicate ed eventuali errori, rendendo più robusto il sistema</p>
        <h4>Formalizzazione a stati finiti (QAK)</h4>
        <p>Si introducono dunque due componenti <i>Software</i>:</p>
        <ul>
            <li>Il <code>DepositRequestHandler</code>: attore che gestisce le richieste in entrata al sistema dallo <r>Smart Device</r></li>
            <li>Lo <code>SmartDevice</code>: attore che simula l'interazione dello <r>Smart Device</r> con il nostro <code>DepositRequestHandler</code></li>
        </ul>
        <h5>DepositRequestHandler Actor</h5>
        <pre><code>
QActor depositrequesthandler context ctxwasteservice{
	[# 	var accepted = false;
		val name = "RequestHandler"
	#]
	State s0 initial {
	<b>...</b>
	}
	Goto waiting

	State waiting{
	<b>...</b>
	}
	Transition t0 whenRequest wasteDeposit -> requestHandling

	State requestHandling {
	<b>...</b>
	}
	Goto requestAccepted if[# accepted == true #] else requestRejected

	State requestAccepted {
	<b>...</b>
	}
	Goto pickingUp

	State requestRejected {
	<b>...</b>
	}
	Goto waiting

	State pickingUp {
	<b>...</b>
	}
	Goto waiting
}
</code></pre>
        <p><a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/WasteServiceCtx_QAK/src/WasteServiceCtx_v3.0.qak"> Metamodello QAK depositrequesthandler</a></p>

        <h5>Smart Device</h5>
        <p>Lo Smart Device viene utilizzato dal driver per approcciare all'INDOOR mandando una richiesta per depositare il carico specificando il tipo di materiale e il TruckLoad.
            La richiesta da inviare è stata formalizzata precedentemente nel paragrafo relativo alla <a href=#wasteTruckRequest>WasteTruckRequest</a>.
        <pre><code>
QActor smartdevice context ctxsmartdevice{
	[# var request_ID = 0 #]

	State s0 initial{
	<b>...</b>
	}
	Goto idle

	State idle {
	<b>...</b>
	}
	Transition t0 whenTime 10000 -> truckArrived

	State truckArrived {
	<b>...</b>
	}
	Transition t1 	whenTime  10000 -> truckArrived
					whenReply loadaccept -> waitPickUp
					whenReply loadrejecetd -> truckGoAway

	State waitPickUp {
	<b>...</b>
	}
	Transition t2 whenMsg pickupOk -> truckGoAway

	State truckGoAway {
	<b>...</b>
		}
	Transition t3 whenTime 3000 -> idle
}
</code></pre>

        <p><a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/SmartDeviceCtx_QAK/src/SmartDeviceCtx_v1.0.qak"> Metamodello QAK SmartDevice</a></p>

    <h4>Modello dell'interazione</h4>
        </br><img src="./img/WasteTruckRequest-1.2.png" alt="WasteTruckRequestProtocol">
        <k>Togliere l'ok</k>
        <p>Il committente ha specificato che sarebbe meglio mandare via il truck il prima possibile, per questo motivo
            va confermato il pickup del trolley allo <r>Smart Device</r> non appena il <r>DDR</r> ha terminato lo scarico.</p>

    <h4>Revisione V3.2</h4>
        <p>Non essendo specificati altri comportamenti per il <r>Waste Truck</r> non risulta necessario l'invio di entrambi i messaggi <code>loadaccept</code> e <code>pickupOk</code>. La formalizzazione dei messaggi e dell'interazione Request/Response evolve come segue:</p>
        <pre><code>
	Request wasteDeposit	: 	wasteDeposit(ID, TYPE, TRUCKLOAD)
	Reply loadaccept	: 	loadaccept(ID)
	Reply loadrejecetd	: 	loadrejecetd(ID)
	    </code></pre>
        <p>Viene modificato il significato della <code>loadaccept</code> come segue:</p>
                <ul><li>La <code>loadaccept</code> verrà inviata direttamente al completamento dello scarico dei rifiuti da parte del <r>DDR</r> svincolando direttamente il <r>Waste Truck</r></li></ul>
        <p>Ciò aggiunge il vantaggio alla nostra architettura di non aver bisogno avere conoscere del contesto dello <r>SmartDevice</r> nel <r>DepositRequestHandler</r> in quanto dovrà solo effettuare la reply delle richieste.</p>

        <pre><code>
QActor depositrequesthandler context ctxwasteservice{
	[#
		...
	#]
	State s0 initial {
		...
	}
	Goto waiting

	State waiting{
		...
	}
	Transition t0 whenRequest wasteDeposit -> requestHandling

	State requestHandling {
		...
	}
	Goto pickingUp if[# accepted == true #] else requestRejected

	State requestRejected {
		//Si svincola il Truck
	}
	Goto waiting

	State pickingUp {
		request transporttrolley -m pickupReq : pickupReq($ID, $T)
	}
	Transition t1 whenReply pickupOk -> pickupOk

	State pickupOk {
		onMsg(pickupOk : pickupOk(ID)){
			replyTo wasteDeposit with loadaccept : loadaccept($ID)  //Moved here (V3.2)
		}
	}
	Goto waiting
}
</code></pre>
        <p><a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/WasteServiceCtx_QAK/src/WasteServiceCtx_v3.2.qak"> Metamodello QAK DepositRequestHandler V3.2</a></p>
        <p><a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/SmartDeviceCtx_QAK/src/SmartDeviceCtx_v3.2.qak"> Metamodello QAK SmartDevice V3.2</a></p>

        <img src="./img/WasteTruckRequest-V3.2.png" alt="DepositRequest V3.2 - New interaction model">
        <img src="" alt="Qak Architecture">


        <h4>Modellazione <r>Transport Trolley</r> - <r>DepositRequestHandler</r> (V3.3)</h4>
        <p>Avendo ora introdotto il componente <r>DepositRequestHandler</r> descriviamo una interazione esemplificativa con il <r>TransportTrolley</r></p>
        <pre><code>
    Request pickupReq : pickupReq(ID, T)	//Richiesta di pickup di un relativo materiale
    Reply pickupOk : pickupOk(ID)		//Risposta di fine pickup, relativa ad una richiesta
        </code></pre>

    <img src="" alt="WasteService Arch. V3.3">

    <p>A seguire il riferimento al metamodello eseguibile del contesto: <a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/WasteServiceCtx_QAK/src/WasteServiceCtx_v3.3.qak">WasteServiceCtx_v3.3.qak</a></p>

    <h4>Modello di interazione Aggiornato</h4>
        <p>DepositRequest accettata:</p>
        <img src="./img/WasteTruckRequest-V3.3-complete.png" alt="WasteService Interaction. V3.3">

        <p>DepositRequest rifiutata</p>
        <img src="./img/WasteTruckRequest-V3.2-Reject-complete.png" alt="WasteService Interaction. V3.3">

  <!------------------------ ------------------------>

        <h3>Led</h3>
        <p>Strumento connesso in output al componente RaspberryPI esterno al <r>DDR Robot</r>.</p>
        <ul>Individuiamo e definiamo TRE modalità:
            <li>LedOff: quando il TT è in HOME</li>
            <li>LedOn: quando il TT è fermo</li>
            <li>LedBlink: quando il TT è in movimento, o sta scaricando/caricando materiale</li>
        </ul>
        <pre><code>
    enum LedState = {LedOff, LedOn, LedBlink};
        </code></pre>

        <p>Il committente fornisce già del software relativo al led in <b>it.unibo.radarSystem22.domain</b>, e in <b>unibo.ledqak22</b>.
            L’interazione tra <b>WasteService</b> e <b>Raspberry</b> avviene mediante un attore che si occuperà di
            ricevere il segnale in input ed emetterà un evento per il comportamento del led.
        </p>
	<pre><code>
QActor led context ctxRaspberry {
	[#
		val name = "LedActor"	
	#]
	
	State off initial{
	<b>...</b>
	}
	Transition t0 whenEvent robotMoving -> blink
	
	State on {
	<b>...</b>
	}
	Transition t3 whenEvent robotMoving -> blink
	
	State blink {
	<b>...</b>
	}
	Transition t1 whenEvent robotAtHome -> off
				  whenEvent robotStopped -> on
	
	}
	</code></pre>
	
	<p><a target="_blank" href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/RaspberryCtx_QAK/src/ctxRaspberry_v3.0.qak"> Metamodello QAK Led</a></p><br>

    <!------------------------ ------------------------>

        <h3>Sonar</h3>
        <p>Strumento connesso in input al componente RaspberryPI esterno al <r>DDR Robot</r>.</p>

        <p>Il software relativo al sonar è fornito dal committente in <b>unibo.basicrobot22,
            it.unibo.radarSystem22.domain,
            unibo.sonarqak22</b>.</p>
        <p>Un attore emetterà eventi a seconda della distanza rilevata dal sonar e manda comandi al sonar.</p>

<p>Sonar Qak già implementato ----> credo che sia già stato fatto qui Nel package unibo.actor22.events della directory test del progetto unibo.actor22, riportiamo la classe SonarActor22 
che definisce il Sonar come un attore proattivo e reattivo.
<p><a target="_blank" href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/SonarObservable.html#il-sonar-come-attore-che-emette-eventi"> Documentazione SonarActor22</a></p>
<p><a href="https://github.com/anatali/issLab2022/blob/main/unibo.sonarqak22/src/sonarqak22.qak">Metamodello QAK SonarQak22</a></p>
    <!------------------------ ------------------------>

        <h4>DLimit</h4>
        <p> Distanza limite relativa al <r>Sonar</r> espressa in numero decimale.</p>
        <pre><code>
    val DLIMIT	:	Float
        </code></pre>

        <p>Se la distanza corrente misurata dal Sonar è ≤ DLIMT, il robot deve fermarsi. Quando la distanza corrente è > DLIMIT il robot è libero di muoversi.
            Definiamo la costante <b>DLIMIT</b>:</p>

        <ul>Più precisamente, quello che ci si aspetta quando la distanza diventa ≤ DLIMT, è che:
            <li>Se il robot si sta muovendo esso si ferma. Riprenderà il moto solo quando la distanza torna <code>> DLIMIT</code></li>
            <li>Ogni altra operazione del robot deve terminare. Una volta terminata si rimane in attesa finché la
                distanza non ritorna <code>> DLIMIT</code></li>
        </ul>

        <ul>Il blocco del trolley in conseguenza di un ‘allarme’ individuato dal Sonar dovrebbe avvenire ‘il prima
            possibile’.
            <li>PUNTO 2 in definizione DLIMIT ... Cioè va fermato/pausa qualsiasi cosa sta facendo. Non aspettiamo che
                finisce un azione.
            </li>
        </ul>
        <br>

<br>

        <h3>Gestione tempo di raccolta/deposito del materiale dal truck</h3>
        <p>Il commitente precisa che il tempo di raccolta del materiale del truck è sempre limitato e prevedibile,
            mentre il tempo necessario per il deposito potrebbe essere anche alquanto lungo.</p>
        <p>Significa che:</p>
        <ul>
            <li>Avremo un <code><i>PickingTime</i></code> definito</li>
            <pre><code>var pickingTime : int (seconds)</code></pre>
        </ul>
        <n> Potrà essere usato per gestire il reinvio di richieste da parte dello SmartDevice allo scadere di un Timeout. Come già implementato nel modello eseguibile <a href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/SmartDeviceCtx_QAK/src/SmartDeviceCtx_v3.3.qak">SmartDeviceCtx_v3.3</a>
            <br>
            Per quanto riguarda invece lo scarico, avendo un modello a scambio di messaggi con interazioni ad eventi non risulta un problema.
        </n>

<br>
    <!------------------------ ------------------------>


        <h3>WasteServiceStatusGUI</h3>
		<br>
        <p>Pannello di controllo che permette al ServiceManager di monitorare:
            <ul>
                <li>La <b>posizione</b> del <r>Transport trolley</r>: intesa come una delle 4 posizione definite nella service Area (home, indoor, plasticBox, glassBox).</li>
        <li>Lo <b>stato</b> del <r>Transport Trolley</r>: ovvero se è in movimento, se è bloccato, se fermo o sta scaricando o caricando.</li>
                <li>Lo stato corrente dei due contenitori <b>PLASTICBOX</b> e <b>GLASSBOX</b>: ovvero il livello di riempimento corrente.</li>
                <li>Lo stato del <b>LED</b>: acceso, spento on in <i>blinking</i></li>
            </ul>
            <pre><code>
    enum class TransportTrolleyState { REST, MOVING, PICKINGUP, DROPPINGOUT, HALT, BLOCKED }
    enum class TTPosition { home, indoor, plasticbox, glassbox}
    var CurrentPB, CurrentGB : float
    enum class LedState { on, off, blink }
            </code></pre>
    </p>

        <p>Il <r>WasteServiceStatusGUI</r> è inteso come un sistema composto da:</p>
        <ul>
            <li>Una <b>Interfaccia Grafica Web</b> che permetta la visualizzazione di tutte queste info.</li>
            <li>Un <b>Attore <i>osservatore</i></b> che osservi le variabili condivise e aggiorni i valori dell'<i>Interfaccia Grafica Web</i> </li>
        </ul>

<br>

    <!------------------------ ------------------------>

    </div>

    <h2>Logical Architecture</h2>

    <img src="" alt="General Logical Architecture">
	
	
    <p>Riepilogo di cosa è requisito e cosa no, e di cosa è già stato sviluppato e cosa no</p>
    <ul>
        <li>Lo <i>smartdevice</i> è già stato sviluppato (o comunque è parte dei test), le richieste/risposte (<i>depositrequest</i>, <i>loadaccept</i>, <i>loadrejected</i>) sono requisito.</li>
        <li>Il <i>basicrobot</i> è già stato sviluppato, le interazioni con il robot definite in termini di operazioni di message-passing (<i>cmdbase</i>, <i>cmdstep</i>, <i>situated</i>) sono quindi predefinite.</li>
        <li>Il <i>wasteservice</i> è da sviluppare, l'interfaccia che espone verso l'esterno (<i>depositrequest</i>, <i>loadaccept</i>, <i>loadrejected</i>) è requisito, mentre l'interazione verso componenti interni (comandi da mandare al TT e aggiornare la capacità dei contenitori) per il momento non è stata considerata.</li>
        <li>Il <i>transporttrolley</i> è da sviluppare, e sarà oggetto di analisi del prossimo sprint. Inoltre è ancora incerta la collocazione di questo componente (IN QUALE CONTESTO LO COLLOCHIAMO?).</li>
        <li>Il <i>sonar</i> e il <i>led</i> sono da sviluppare: è disponibile software che dovrà essere analizzato prima di essere eventualmente utilizzato/adattato, VALUTARE SE LE INTERAZIONI SONO UN REQUISITO O GI&Agrave SONO IMPLEMENTATE.</li>
        <li>Il <i>wasteservicestatusgui</i> è da analizzare/sviluppare, e sarà oggetto degli sprint successivi (al momento è incerta la collocazione e/o l'esistenza sotto forma di attore del componente). Le interazioni (TUTTE LE INFO PASSATE ALLA GUI) sono da valutare e al momento restano vaghe (SONO REQUISITO?).</li>
    </ul>


<h2>Work Plan</h2>
<div class="remark">
    <p>Il primo sprint si occuperà della business logic dell'applicazione, quindi degli aspetti principali della logica di smistamento e della navigazione verso le aree designate.</p>
    <p>Successivamente si provvederà ad integrare <b>LED</b> e <b>Sonar</b>.</p>
    <p>Infine ci si occuperà della <b>WasteServiceStatusGUI</b>.</p>
</div>
<br/><br/> 	
</div>  



    <!-- USEFUL
    <table style="width:100%" border="1">
    <tr>
    <td style="width:50%">
    </td>
    <td></td>
    </tr>
    </table>
    -->

    <br><br>
</div>

<div style="background-color:rgba(86, 56, 253, 0.9); width:100%; height: 28vw; text-align:left; color:white;">
    <p style="text-align: center; font-size: 12pt;">Studenti: Luca Landolfi, Antonio Franzese, Luca De Risi</p>
    <p style="text-align: center; font-size: 12pt;">Email: luca.landolfi3@studio.unibo.it,  antonio.franzese4@studio.unibo.it, luca.derisi@studio.unibo.it;</p>
    <div style="display: block; margin: 0 15vw;">
        <img src="./img/img_luca.png"   style="float: left; width: 19vw; height: 20vw">
        <img src="./img/img_anto.jpg"   style="float: left; width: 19vw; height: 20vw">
        <img src="./img/img_lude.JPG"   style="float: left; width: 22vw; height: 20vw">
    </div>
</div>
</body>
</html>