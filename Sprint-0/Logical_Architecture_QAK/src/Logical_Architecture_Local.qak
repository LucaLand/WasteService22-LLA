System logicalarchitecture

	
	//WasteService - SmartDevice
	Request depositRequest : depositRequest(ID, Type, TruckLoad)
	Reply loadaccept : loadaccept(ID)
	Reply loadrejecetd : loadrejecetd(ID)
	

	//To BasicRobot22
	Dispatch cmd       	: cmd(MOVE)      
	Dispatch end       	: end(ARG)   
	  
	Request step       : step( TIME )	
	Reply   stepdone   : stepdone(V)  
	Reply   stepfail   : stepfail(DURATION, CAUSE)



Context ctxraspberry ip[host="localhost" port=8078]
Context ctxsmartdevice ip[host="localhots" port=8074]
Context ctxddrobot ip[host="localhost" port=8070]
Context ctxwasteservice ip[host="localhost" port=8076]

//Context ctxgeneral ip[host="localhost" port=8092]




//WasteService Ctx
QActor transporttrolley context ctxwasteservice {
	[#
		val name = "TransportTrolley"
		val version = "V1.0"
		
		var ID = ""
		var materialType = ""
		var pos = "" 		//pos : home, indoor, plasticbox, glassbox
	#]

	State s0 initial{
		println("\t $name: Started! $version") color blue
	} 
	Goto waiting

	State waiting {
		[# pos = "home" #]
		updateResource [# pos #]
		println("\t $name: TransportTrolley at Home!") color blue			//We presume it starts in its home position
		
		println("\t $name: ready and waiting for pickupRequest!") color blue
	}

	State pickup {
		
			println("\t $name: pickupRequest($ID) received!") color blue
			
			
			//Sending messages to BasicRobot22
			println("\t $name: Sending cmd(MOVES) to BasicRobot22") color blue
			println("\t $name: Robot going from $pos to Indoor") color blue
			
			//Robot Moving to Indoor
			
			delay 10000

	} 
	Goto depositPlastic if[# materialType == "plastic" #] else depositGlass

	State depositPlastic {
		println("\t $name: Going to PlasticBox!") color blue
		
		//Sending cmd(MOVES) to BasicRobot22
		forward basicrobotexample -m cmd:cmd(DepositPlastic)
		
		delay 3000
		[# pos = "plasticbox" #]
		updateResource [# pos #]
		
		//Depositing
		println("\t $name: Depositing Plastic!") color blue
		delay 6000
	} 
	Transition t1 whenTime 500 -> goHome

	State depositGlass {
     	println("\t $name: Going to GlassBox!") color blue
     	
     	
		//Sending cmd(MOVES) to BasicRobot22
		forward basicrobotexample -m cmd:cmd(DepositGlass)
		
		delay 5000
		[# pos = "glassbox" #]
		updateResource [# pos #]
		
		//Depositing
		println("\t $name: Depositing Glass!") color blue
		delay 6000
	} 
	Transition t2	whenTime 500 -> goHome

	State goHome {
     	println("\t $name: Finished Deposit - Going home") color blue
     	forward basicrobotexample -m cmd:cmd(GoHome)
		delay 7000
	}
	Goto waiting
     
}




QActor wasteservice context ctxwasteservice {
	[# 	
		val name = "WasteService"
		val version = "0"
		
		//Only one Request at time
		var accepted = false; 
		var ID = "0"
		var T = ""
		var L = ""
	#]
	
	State s0 initial {
		println("\t $name: Started! $version") color green
	}
	Goto waiting
	
	State waiting{
		println("\t $name: ready and waiting for deposit request...") color green
	}
	Transition t0 whenRequest depositRequest -> requestHandling
	
	State requestHandling {
		println("\t $name: Deposit Request arrived!") color green
		[# accepted = false #]

		onMsg(depositRequest : depositRequest(ID, T, L)){
			[# 	ID = payloadArg(0)
				T = payloadArg(1)
				L = payloadArg(2)
			#]
			//println("Request: ($ID, $T, $L)") color green
			if[# ID.toInt()%2 == 0 #]{			//If di esempio test per avere risposte alternate
				[# accepted = true #]
			}else{
				[# accepted = false #]
			}
		}
	}
	Goto pickingUp if[# accepted == true #] else requestRejected 
	
	State requestRejected {
		replyTo depositRequest with loadrejecetd : loadrejecetd($ID)
		println("\t $name: Request -$ID- Refused!") color green
	}
	Goto waiting
	
	State pickingUp {
		println("\t $name: Request -$ID- Accepted!") color green
		println("\t $name: Requesting pickingUp...") color green
		
		delay 7000
	}
	Goto pickupOk
	
	State pickupOk {
		println("\t $name: PickupOK received! Finished ${payloadArg(0)}") color green
		replyTo depositRequest with loadaccept : loadaccept($ID)
	}
	Goto waiting
}




//SmartDevice Ctx

QActor smartdevice context ctxsmartdevice {
	[#
		val name = "SmartDevice"
		val version = "V1.0"
		
		var request_ID = 0 
		#
	]
	
	State s0 initial{
		println("\t $name: Started! $version") color yellow
	}
	Goto idle
	
	
	State idle {
		println("\t $name: Waiting for Truck...") color yellow
		[# request_ID ++ #]
	}
	Transition t0 whenTime 1000 -> truckArrived  //Changed V3.3 - testing multiple requests

	
	State truckArrived {
		[# val ID = request_ID #]
		if[# ID.toInt()%3 == 0 #]{
			delay 10000
		}
		println("\t $name: Truck Arrived!") color yellow
		println("\t $name: Sending request -$request_ID-") color yellow
		
		if[# ID.toInt()%2 == 0 #]{
			request wasteservice -m depositRequest : depositRequest($ID , plastic, 10)
		} else {
			request wasteservice -m depositRequest : depositRequest($ID , glass, 8)
		}
	}
	Transition t1 	whenTime  20000 -> truckArrived				//(Req) Avendo lo scarico un tempo limitato possiamo presumere che se passa troppo tempo si sia persa la richiesta e la reinviamo. Abbiamo anche un meccanismo a ID per evitare richieste duplicate
					whenReply loadaccept -> truckGoAway
					whenReply loadrejecetd -> truckGoAway
			
	
	State truckGoAway {
		onMsg(loadrejecetd : loadrejecetd(ID)){
			println("\t $name: Carico - ${payloadArg(0)} - Rifiutato!") color yellow
		}
		
		onMsg(loadaccept : loadaccept(ID)){
			println("\t $name: Scarico - ${payloadArg(0)} - Completato!") color yellow
		}
		
		println("\t $name: Il Truck puÃ² andare!") color yellow
	}
	Transition t3 whenTime 1000 -> idle  //Un po' di attesa per simulare il via del camion
}



//Raspberry Ctx

//Led
QActor ledactor context ctxraspberry {
	[#
		val name = "LedActor"
		val version = "V1.0"
		
		var ledState = "off"
	#]
	
	State s0 initial {
		println("\t $name: Started! $version") color red
	}
	Goto handleRobotStateEvent
	
	
	State handleRobotStateEvent {
		println("\t $name: Handling RobotStateEvent change!") color red
		[#  
			val robotState = "null"
		#]
		
		if[# robotState == "atHome" #]{
			[# ledState = "off" #]
		}
		if[# robotState == "moving" #]{
			[# ledState = "blinking" #]
		}
		if[# robotState == "stopped" #]{
			[# ledState = "on" #]
		}
		
		println("\t $name: Led state- $ledState") color red
		updateResource [# ledState #]
	}
	Transition t0 	whenTime 8000 -> handleRobotStateEvent
	
}



//Sonar
QActor sonaractorexemple context ctxraspberry {
	[#
		val name = "SonarActorExemple"
		val version = "V.Ex"
	#]
	
	State s0 initial {
		println("\t $name: Started! $version")
	}
	Goto s1
	
	State s1 {
		
	}
}





//BasicRobot22

QActor basicrobotexample context ctxddrobot {
	[#
		val name = "BasicRobotExemple"
		val version = "V.Ex"
	#]
	
	State s0 initial{
		println("\t $name: Started! $version")
	}
	Goto s1
	
	State s1 {
		
	}
}





//WasteServiceGui

QActor wasteserviceguiactor context ctxwasteservice {
	[#
		val name = "WasteServiceGui"
		val version = "V1.0"
		val active = true
		
		var TTState = "null"
		var pos = "null"
		var Pb = "null"
		var Gb = "null"
		var ledState = "null"
	#]
	
	State s0 initial {
		println("\t $name: Started! $version")
		println("\t $name: Ready to observe and update")
	}
	Goto handleChanges if [# active #] else deactivated
	
	State handleChanges {
		//printCurrentMessage
		discardMsg Off
		
		println("\t $name: GUI STATE:")
		println("\t\t\t TTState: $TTState")
		println("\t\t\t Pos: $pos")
		println("\t\t\t PB: $Pb - GB: $Gb")
		println("\t\t\t LedState: $ledState")
		
	}
	Transition t0 	whenTime 20000 -> handleChanges
					
	State deactivated {
		
	}
	//Goto handleChanges if [# active #] else deactivated
	
	
}

