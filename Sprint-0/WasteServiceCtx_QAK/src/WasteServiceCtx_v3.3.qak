System wasteservice  //V3.3

//Request Handler
	Request wasteDeposit : wasteDeposit(ID, Type, TruckLoad)
	Reply loadaccept : loadaccept(ID)
	Reply loadrejecetd : loadrejecetd(ID)
	
	
//Transport Trolley
	Request pickupReq : pickupReq(ID, T)	//Richiesta di pickup di un relativo materiale
	Reply pickupOk : pickupOk(ID)			//Risposta di fine pickup, relativa ad una richiesta
	
//Led Events
	Event robotAtHome : robotAtHome(E)
	Event robotMoving : robotMoving(E)
	Event robotStopped : robotStopped(E)
	

Context ctxRaspberry ip[host="127.0.0.1" port=8076]
Context ctxwasteservice ip[host="localhost" port=8072]


ExternalQActor led context ctxRaspberry



//Reuqest Handler Actor V3.2
QActor depositrequesthandler context ctxwasteservice{
	[# 	
		val name = "RequestHandler"
		val version = "V3.2"
		
		//Only one Request at time
		var accepted = false; 
		var ID = ""
		var T = ""
		var L = ""
	#]
	State s0 initial {
		println("\t $name: Started! $version")
	}
	Goto waiting
	
	State waiting{
		println("\t $name: ready and waiting for deposit request...")
	}
	Transition t0 whenRequest wasteDeposit -> requestHandling
	
	State requestHandling {
		println("\t $name: Deposit Request arrived!")
		[# accepted = false #]

		onMsg(wasteDeposit : wasteDeposit(ID, T, L)){
			[# 	ID = payloadArg(0)
				T = payloadArg(1)
				L = payloadArg(2)
			#]
			println("Request: ($ID, $T, $L)")
			if[# ID.toInt()%2 == 0 #]{			//If di esempio test per avere risposte alternate
				[# accepted = true #]
			}else{
				[# accepted = false #]
			}
		}
	}
	Goto pickingUp if[# accepted == true #] else requestRejected 
	
	State requestRejected {
		replyTo wasteDeposit with loadrejecetd : loadrejecetd($ID)
		println("\t $name: Request -$ID- Refused!")
	}
	Goto waiting
	
	State pickingUp {
		println("\t $name: Request -$ID- Accepted!")
		println("\t $name: Requesting pickingUp...")
		request transporttrolley -m pickupReq : pickupReq($ID, $T)
	}
	Transition t1 whenReply pickupOk -> pickupOk
	
	State pickupOk {
		onMsg(pickupOk : pickupOk(ID)){
			println("\t $name: PickupOK received! Finished ${payloadArg(0)}")
			replyTo wasteDeposit with loadaccept : loadaccept($ID)
		}
	}
	Goto waiting
}








//Transport Trolley V3.3
QActor transporttrolley context ctxwasteservice {
	[#
		val name = "TransportTrolley"
		val version = "V3.3"
		
		var materialType = ""
		var pos = "H"		//Added V3.3 - pos : "H, I, PB, GB" Presuming starts from Home	
	#]
//[pos] Avendo questa variabile posizione si potrebbe pensare di modellare diversamente gli eventi con un solo evento e questa variabile come payload
	
	
	State s0 initial{
		println("\t $name: Started! $version")
	}
	Goto waiting
	
	
	State waiting { //AtHome
		[# pos = "H" #]		//Added V3.3
		println("\t $name: TransportTrolley at Home!")			//We presume it starts in its home position
		emit robotAtHome : robotAtHome(1)
		println("\t $name: ready and waiting for pickupRequest!")
	}
	Transition t0 whenRequest pickupReq -> pickup
	
	
	State pickup {
		//Useremo una variabile globale per la posizione [# pos #]
		onMsg(pickupReq : pickupReq(ID, T)){
			[# 	
				val ID = payloadArg(0)
				materialType = payloadArg(1)
			#]
			println("\t $name: pickupRequest($ID) received!")
			println("\t $name: Robot going from $pos to Indoor")	//Added V3.3 - Testing robot movement form different position
			emit robotMoving : robotMoving(2)
			delay 10000
			
			[# pos = "I" #]		//Added V3.3
			println("\t $name: PickupOK!")
			replyTo pickupReq with pickupOk : pickupOk($ID)
		}
	}
	Goto depositPlastic if[# materialType == "plastic" #] else depositGlass
	
	
	State depositPlastic {
		println("\t $name: Depositing plastic!")
		delay 7000
		[# pos = "PB" #]		//Added V3.3
	}
	Transition t1	whenTime 100 -> goHome
					whenRequest pickupReq -> pickup
	
	
	
	State depositGlass {
		println("\t $name: Depositing glass!")
		delay 7000
		[# pos = "GB" #]		//Added V3.3
	}
	Transition t2	whenTime 100 -> goHome
					whenRequest pickupReq -> pickup
	
	
	State goHome {
		println("\t $name: Finished Deposit - Going home")
		delay 7000
	}
	Goto waiting
	
}
