System smartdevice
	Request wasteDeposit : wasteDeposit(ID, Type, TruckLoad)
	Reply loadaccept : loadaccept(ID)
	Reply loadrejecetd : loadrejecetd(ID)
	
//	Removed V3.2
//	Dispatch pickupOk : pickupOk(ID)
	
	
Context ctxwasteservice ip[host="127.0.0.1" port=8072]
Context ctxsmartdevice ip[host="localhost" port=8074]

ExternalQActor depositrequesthandler context ctxwasteservice



QActor smartdevice context ctxsmartdevice{
	[#
		val name = "SmartDevice"
		val version = "V3.2"
		
		var request_ID = 0 
		#
	]
	
	State s0 initial{
		println("\t $name: Started! $version")
	}
	Goto idle
	
	
	State idle {
		println("Smart Device Waiting for Truck...")
		[# request_ID ++ #]
	}
	Transition t0 whenTime 10000 -> truckArrived
	
	State truckArrived {
		println("Truck Arrived!")
		println("Sending request -$request_ID-")
		[# val ID = request_ID #]
		
		request depositrequesthandler -m wasteDeposit : wasteDeposit($ID , 0, 10)
	}
	Transition t1 	whenTime  20000 -> truckArrived				//(Req) Avendo lo scarico un tempo limitato possiamo presumere che se passa troppo tempo si sia persa la richiesta e la reinviamo. Abbiamo anche un meccanismo a ID per evitare richieste duplicate
					whenReply loadaccept -> truckGoAway
					whenReply loadrejecetd -> truckGoAway
					
//	Removed V3.2	
//		
//	State waitPickUp {
//		println("Load Accepted -$request_ID- : waiting pickUp")
//	}
//	Transition t2 whenMsg pickupOk -> truckGoAway
	
	State truckGoAway {
		printCurrentMessage
		onMsg(loadrejecetd : loadrejecetd(ID)){
			println("Carico -${payloadArg(0)}- Rifiutato!")
		}
		
		onMsg(loadaccept : loadaccept(ID)){
			println("Scarico -${payloadArg(0)}- Completato!")
		}
		
		println("Il Truck puÃ² andare!")
	}
	Transition t3 whenTime 3000 -> idle  //Un po' ti attesa per simulare il via del camion
}