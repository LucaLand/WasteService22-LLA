<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">


<head>
    <title>Iss2023-LLA-Sprint1</title>
    <link href="./defaultStyle.css" rel="stylesheet">
	<link href="./menuCss.css" rel="stylesheet">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> <!--  To solve accent problems  -->
</head>


<body>
<div id="top">
    <h1>Progetto Finale ISS - Waste Service</h1>
</div>
<div class="remark">
<nav>
    <ul>
        <li><a href="../../Sprint-0/userDocs/Sprint0-LLA.html">sprint0</a></li>
        <li><a href="./Sprint1-LLA.html">sprint1</a></li>
    </ul>
</nav>
</div>

    <h2>Introduction</h2>
    <div class="remark">
	<p>
	Progetto finale di ISS che consiste nel realizzare un sistema di gestione dei rifiuti in cui un robot svolge il compito di trasportare i materiali dal camion ai relativi contenitori di smistamento. 
	Attualmente, ci concentriamo su una fase preliminare di analisi dei requisiti, che consiste nel comprendere le esigenze del cliente e tradurle in una forma formalizzata e strutturata.
	</p>
	</div>

    <h2>Requirements</h2>
    <div class="remark">
        <p>Si riporta la pagina di requisiti del committente: <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/TemaFinale22.html" traget="_blank" >Waste
            Service 22.pdf</a></p>
		<p>Inoltre si riporta il file dei requisiti dello Sprint0: <a href="../../Sprint-0/userDocs/Sprint0-LLA.html#Requirements">Requisiti Sprint0</a>
    </div>

    <!----------------------- REQUIREMENT ANALYSIS --------------------------->

    <h2>Scrum Goal and Work Plan</h2>
    <div class="remark">
	<h4>Scrum goal:</h4>
	Obiettivo dello Sprint1 è la creazione di una prima demo (su ambiente virtuale) che tenga presente delle richiesete del commitente, ossia che il truck vada via il prima possibile 
	e che il sistema possa ricevere altre richieste anche durante la fase di deposito dei rifiuti. Questi, di fatto, sono i punti principali che contengono la core business logic del problema (descrivono
	infatti la <b>Service area</b> e la <b>Deposit action</b>).
	
	<h4>Work plan:</h4>
	<ul>
        <li>Analisi del problema di come affrontare la navigazione, anche in relazione al SW già sviluppato <br>
            (possibile visitare la pagina riassuntiva <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/Applicazioni22.html">Applicazioni22</a> dei moduli sviluppati)</li>
        <li>Analisi delle responsabilità e delle interazioni tra i componenti <i>wasteservice</i>, <i>trasporttrolley</i> e <i>basicrobot</i></li>
        <li>Sviluppo / adattamento di tali componenti</li>
        <li>Realizzazione di un modello eseguibile (a tal proposito verrà utilizzato il metamodello <a href="../../Sprint-0/userDocs/QAK.html">QAK</a>).</li>
        <li>Realizzazione di un (più completo) test-plan per il modello</li>
    </ul>
        
    </div>
	
	<!--PROBLEM ANALYSIS-->
	<a NAME="ProblemAnalysis"></a>
	<h2>Problem analysis</h2>
	<div class="remark">
        <div class="remark remark2">
            <h4>Architettura logica precedente:</h4>
            <img src="img/LogicalArch_R2.png" alt="General Logical Architecture" style="width: 600px;" >
            <p style="width: 100%; text-align: right;"><a href="./img/Legenda.png">Legenda.png</a></p>
            <br>

            <h4>Focus Sprint-1</h4>
            <p>Nello Sprint-1 si vedrà dunque un focus sui seguenti componenti e sui loro modelli.</p>
            <img src="img/Spint-1_Focus_Initial.png" alt="Architecture Focus Sprint-1" style="width: 80%">
            <span>Sprint-0:
                <a href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Qak_Models/SmartDevice.qak">SmartDevice.qak</a>  ||
                <a href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Qak_Models/WasteService.qak">WasteService.qak</a>  ||
                <a href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Qak_Models/TransportTrolley.qak">TransportTrolley.qak</a>  ||
                <a href="https://github.com/anatali/issLab2022/blob/main/unibo.basicrobot22/src/basicrobot.qak">BasicRobot22.qak</a>
            </span>
        </div>






    <h3>1 - Simulazione Smart Device</h3>
		<p>
		
		Come da requisiti, lo <b>Smart Device</b> non dovrà essere implementato. Per facilitare la messa appunto dell'applicazione introduciamo un <b><i>Mock-object</i></b>, 
		cioè un dispositivo simulato che riproduce il comportamento dei dispositivi reali in modo controllato, in questo caso verrà utilizzato per la simulazione dello <b>Smart Device</b>.
		Questo meccanismo ci consente di andare a simulare l'interazione tra lo <b>Smart Device</b> e il <b>WasteService</b>, in particolare il primo invierà una <i>DepositRequest</i>
		e si metterà in attesa di una risposta.
		</br>
		</br>
		Di seguito viene riportata la documentazione relativa ai <b><i>Mock-object</i></b>: <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2022/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/RadarSystemProgetto.html#sprint1-componenti-per-i-dispositivi-di-i-o"> Mock
		</a>
		
		
		</p>

    <h3>2 - Analisi della Core Business Logic </h3>
        <p>In questa sezione iniziamo con il delineare una prima organizzazione della <i>Logica di Business</i> dei <i>Core Components</i>.</p>
        <ul>
            <li>SmartDevice</li>
            <li><b>WasteService</b></li>
            <li><b>Transport Trolley</b></li>
            <li>BasicRobot22</li>
        </ul>
        <p>Per quanto riguarda lo <code><i>SmartDevice</i></code> e il <code><i>BasicRobot22</i></code> sono già stati definiti precedentemente per quello non verranno analizzati.</p>
        <h4>Macro analisi delle funzionalità:</h4> <!-- e divisione dei compiti tra i componenti:</p> -->
        <ol>
            <li>Il <b>WasteService</b> prende le richieste dello <i>SmartDevice</i> e in base alla capienza dei Box le accetta o rifiuta.</li>
            <li>Il <b>WasteServcie</b> comunica con il <b>Transport Trolley</b> richiedendo il <i>PickUp</i> dei rifiuti dal camion e lo scarico degli stessi in un determinato tipo di Box, in caso di richieste accettate.</li>
            <li>Il <b>Transport Trolley</b> gestirà le richieste di <i>pickUp</i> del <b>WasteService</b> inviando comandi per muovere il <b>BasicRobot22</b> per raggiungere le posizioni desiderate.</li>
            <li>Il <b>Transport Trolley</b> prevede l'invio di una conferma di <i>PickUp</i> al <b>WasteService</b> non appena avrà terminato il <i>pickUp</i>.</li>
            <li>Il <b>Transport Trolley</b> deve prevedere la gestione di richieste di scarico mentre sta ancora eseguendo una <i>Deposit Action</i>.</li>
        </ol>



    <h3 id="sec-GestioneRichieste">3 - <b>WasteService</b>: Analisi Gestione delle richieste</h3>

        <p>Dati i messaggi definiti da requisito nello Sprint-0:</p>
        <pre><code>
 Request depositRequest	: 	depositRequest(TYPE, TRUCKLOAD, ...)
 Reply loadaccept	: 	loadaccept(...)
 Reply loadrejecetd	: 	loadrejecetd(...)
        </code></pre>

        <img src="img/WasteTruckRequest_Architecture.png" alt="WasteTruckRequest Arch" style="width: 500px">

        <p>Si evidenziano i seguenti problemi da anlizzare:</p>
        <ul>
            <li><b>Logica di gestione delle richieste</b></li>
            <li><b>Quando rispondere allo SmartDevice</b></li>
            <li><b>Possibilità di richieste ripetute</b></li>
        </ul>

        <h4>Logica Gestione delle richieste</h4>
            <p>
                Il <b>WasteService</b> per poter gestire le richieste che arrivano dallo <b>Smart Device</b> si avvale dell'utilizzo di due variabili inizializzate nello
                <a href="../../Sprint-0/userDocs/Sprint0-LLA.html#Variables">Sprint0</a>.<br>
                Le variabili contGB e contPB, inizializzate nello Sprint0, sono rispettivamente delle variabili contatori per i due tipi di materiali da depositare e verranno verificate
                con la capienza massima dei box stabilita a priori tramite i valori di MAXGB e MAXPB.
            </p>


            <p>Pseudo codice di gestione delle richieste:</p>
            <pre><code>
When (Request depositRequest(TYPE, TRUCKLOAD)){
    if(contGB OR  contPB + TRUCKLOAD) > MAXGB OR MAXPB{
        Reply loadrejecetd
    }else{
        ... //Richiesta di pickUp del materiale al TransportTrolley
    }
}
            </code></pre>

        <img src="img/WasteService_SmartDevice_Interaction.png" alt="WasteTruckRequest Interaction">

        <div class="remark remark2">
            <span>Formalizzando in linguaggio qak, si traduce nella seguente evoluzione dello stato del <b>WasteService</b>:</span>
            <pre><code>
 State requestHandling {
    ...
    onMsg(depositRequest : depositRequest(ID, T, L)){
        [# Type = payloadArg(0)
            TruckLoad = payloadArg(1).toInt() #]
        println("Request: ($ID, $Type, $TruckLoad)") color green
        if[# Type == "plastic" #]{
            if[# (currentPB + TruckLoad) < MAXPB #]{
                [# accepted = true #]
            }
        }if[# Type == "glass" #]{
            if[# (currentGB + TruckLoad) < MAXGB #]{
                [# accepted = true #]
            }
        }
    }
 } Goto requestAccepted if[# accepted == true #] else requestRejected
            </code></pre>

            <pre><code>
 State requestAccepted {
    //Requesting PickUp to TransportTrolley
    println("\t $name: Requesting Picking Up...") color green
 }
            </code></pre>
        </div>

        <tt>Il <b>WasteService</b> deve dunque richiedere il <i>PickUp</i> del materiale al <b>TransportTrolley</b></tt>



<!---->
        <h4>Aggiornamento e gestione delle variabili di stato dei Box</h4>
            <p>Le variabili <code>currentPB</code> e <code>currentGB</code> vanno aggiornate per la corretta gestione delle richieste.</p>
            <p>Siccome il <b>WasteService</b> può ricevere richieste anche prima che la <i>Deposit Action</i> sia stata completata, si evidenzia la seguente soluzione:</p>
            <ol>
                <li>Le variabili <code>currentPB</code> e <code>currentGB</code> saranno aggiornate non appena una richiesta viene accettata.</li>
                <p>In caso si preveda la possibilità di errori nello scarico dei rifiuti, si implementa un meccanismo di transazioni con conferma:</p>
                <li>Si conserverà il valore precedente delle variabili in due ulteriori variabili: <code>oldPB</code> e <code>oldGB</code></li>
                <li>In caso di conferma di scarico del materiale da parte del <b>TransportTrolley</b>: <code>oldPB</code> e <code>oldGB</code> saranno aggiornate a <code>currentPB</code> e <code>currentGB</code></li>
                <li>In caso di errori e mancato scarico del materiale le variabili current</li>
            </ol>
        <p>In questo modo il sistema è protetto da eventuali errori nel deposito dei materiali, ma si introducono problemi relativi alla notifica degli errori e ulteriori messaggi di conferma scarico da parte del <b>TransportTrolley</b>.</p>
        <p>Siccome il committente non specifica possibilità di errori o malfunzionamenti del robot, si consiglia, in caso di errori e malfunzionamenti di interrompere il funzionamento del sistema, senza la gestione delle variabili in caso di eventuali situazioni di errore.</p>



        <div class="remark remark2">
            <span>Formalizzazione in QAK:</span>
            <pre><code>
     State requestAccepted {
            println("\t $name: Request -$ID- Accepted!") color green
            if[# Type == "plastic" #]{
                [# currentPB += TruckLoad #]
            }
            if[# Type == "glass" #]{
                [# currentGB += TruckLoad #]
            }
        } Goto pickingUp
            </code></pre>
        </div>

        <tt>Attesa conferma del committente: In caso di errori o malfunzionamenti da parte del Robot, il sistema si blocca e termina per poter permettere interventi di manutenzione.<br>
            - Non verranno dunque considerate situazioni di gestione di errori dopo l'accettazione di una richiesta</tt>



<!---->
        <h4>Quando rispondere allo <b>Smart device</b></h4>
            <p>Nell'interazione con il committente, come indicato nello SPRINT-0, si è evidenziato come il <i>Waste Truck</i> sarà libero una volta ricevuta una risposta positiva o negativa. In modo da essere liberato il prima possibile.</p>
            <p>In caso di <code><b>loadrejected</b></code>:</p>
                <ul><li>La risposta viene inviata, come già descritto sopra, non  appena ci si accorge che non può essere accolta.</li></ul>
            <pre><code>
 State requestRejected {
    replyTo depositRequest with loadrejecetd : loadrejecetd(0)
    println("\t $name: Request -$ID- Refused!") color green
 } Goto waiting
            </code></pre>
            <p>Nel caso di <code><b>loadaccepted</b></code>:</p>
                <ul><li>La risposta deve essere inviata dopo che il <b>TransportTrolley</b> ha terminato il <i>PickUp</i></li></ul>
            <pre><code>
 State pickupOk {
    println("\t $name: Pickup finished! Truck ($ID) can go away!") color green
    replyTo depositRequest with loadaccept : loadaccept(0)
 } Goto waiting
            </code></pre>
        <tt>Si necessità di una conferma del <i>PickUp</i> del <b>TransportTrolley</b> al <b>WasteService</b></tt>




<!---->
        <h4>Richiesta e Conferma di PickUp</h4>
            <p>La necessità di richiesta e di conferma del <code>pickUp</code> rappresentano un ulteriore <i>Macro Problema</i>, per cui verranno analizzate nel dettaglio nella sezione successiva: <a href="#sec-Int-WS-TT">Interazione WasteService-TransportTrolley</a></p>


        <h4>Richieste multiple</h4>
        <p>Il <b>WasteService</b> da requisito può ricevere una sola richiesta per Truck, ma può ricevere richieste anche mentre il <b>TransportTrolley</b> sta ancora eseguendo la <i>Deposit Action</i> di un materiale.</p>
        <p>Siccome:</p>
        <ul>
            <li>Da requisito, la <i>Deposit Action</i> è gestita dal <b>Transport Trolley</b></li>
            <li>Il <b>WasteService</b> richiede la <i>Deposit Action</i> al <b>TransportTrolley</b></li>
            <li>Il <b>WasteService</b> risponde alla request subito dopo il <i>PickUp</i> e rimane libero</li>
        </ul>
        <p>La possibilità di ricevere richieste durante l'esecuzione della <i>Deposit Action</i> non influisce sul <b>WasteService</b> ma riguarda il <b>TransportTrolley</b></p>
        <tt>Il <b>TransportTrolley</b> deve prevedere l'arrivo e la gestione di ulteriori richieste di <i>PickUp</i> da parte del <b>WasteService</b> durante l'esecuzione di una <i>Deposit Action</i>.</tt>



<!--        <ul>-->
<!--            <li>Per gestire eventuali casi di richieste ripetute <u>semplicemente si scartano le richieste che arrivano durante la gestione di una richiesta</u></li>-->
<!--        </ul>-->






<!--        -----4-----        -->
    <h3 id="sec-Int-WS-TT">4 - Interazione <b>WasteService</b> e <b>TransportTrolley</b></h3>
        <p>Come evidenziato nella sezione precedente (<a href="#sec-GestioneRichieste">Gestione Delle Richieste</a>) vi è la necessità di interazione tra il <b>WasteService</b> ed il <b>TransportTrolley</b>.</p>

        <h4>Richiesta e Conferma <i>PickUp</i></h4>
            <p>Le interazioni necessarie secondo l'analisi della <a href="#sec-GestioneRichieste">sezione precedente</a> sono:</p>
            <ul>
                <li>Richiesta di <i>PickUp</i> del <b>WasteService</b> al <b>TransportTrolley</b></li>
                <li>Conferma di <i>PickUp</i> del <b>TransportTrolley</b> al <b>WasteService</b></li>
            </ul>

            <p>Essendo:</p>
            <ul>
                <li>L'interazione composta da una richiesta e una conferma obbligatoria</li>
                <li>Ed essendo il <b>WasteService</b> non implicato in ulteriori operazioni durante l'attesa della risposta</li>
            </ul>
            <tt>L'interazione verrà modellata come una <b><i>Request / Response</i></b>.
                <pre><code>
 Request   pickupReq   :   pickupReq(...)
 Reply     pickupOk    :   pickupOk(...)
                </code></pre>
            </tt>
            <img src="img/WasteService_TransportTrolley_Interaction.png" alt="WasteService-TransportTrolley Arch" style="width: 400px">

            <p>Avendo poi <u>delegato</u> l'operazione di <i>Deposit Action</i> al <b>TransportTrolley</b>, questo continuerà la <i>Deposit Action</i> dopo aver scaricato il materiale e aver inviato la <code>PickupOk</code> al <b>WasteServide</b>.
            <br>Questo è possibile in quanto la richiesta di scarico dello <b>SmartDevice</b> è stata già approvata e non sono necessarie operazioni intermedie.</p>
            <p>Dunque il <b>WasteService</b> sarà libero di gestire ulteriori richieste mentre il <b>TransportTrolley</b> continua nel deposito dei materiali.</p>
            <tt>
                <p>Per permettere al <b>TransportTrolley</b> di continuare nell'operazione di Deposito, modelleremo la richiesta con i seguenti parametri:</p>
                <ul>
                    <li><code>TYPE</code>: Necessario per indicare al <b>TransportTrolley</b> dove scaricare i materiali</li>
                    <li><code>ID</code>: Per identificare le richieste e rendere più facile la gestione delle stesse in modifiche future</li>
                </ul>
                <pre><code>
 Request  pickupReq   :   pickupReq(ID, TYPE)
 Reply    pickupOK    :   pickupOk(ID)
                </code></pre>
            </tt>


        <div class="remark remark2">
            <span>Evoluzione del modello in qak del <b>WasteService</b>:</span>
            <pre><code>
 State pickingUp {
    //Requesting PickUp to TransportTrolley
    println("\t $name: Requesting Picking Up...") color green
    request transporttrolley -m pickupReq : pickupReq(ID, Type)
 } Transition t1 whenReply pickupOK -> pickupOk
            </code></pre>

            <span>Evoluzione del modello in qak del <b>TransportTrolley</b>:</span>
            <pre><code>
 State waiting {
    ...
 } Transition t0 whenRequest pickupReq -> handlePickupReq
            </code></pre>

            <pre><code>
 State handlePickupReq {
        onMsg(pickupReq : pickupReq(ID, TYPE)){
            println("\t $name: pickupRequest received!") color blue
        }
 } Goto pickUp
            </code></pre>

            <pre><code>
 State pickUp {
    //Sending messages to move BasicRobot22 into Indoor
    println("\t $name: Going to Indoor!") color blue
    ...
    //Sending pikcup finished
    println("\t $name: Pickup Finished!") color blue
    <q>replyTo pickupReq with pickupOk : pickuoOk(0) caller== wasteservice</q>
 } Goto deposit
            </code></pre>
</div>
        <p>Architettura</p>
        <img src="img/Logical_Architecture_Sprint1-1.png" alt="">

        <p>Interazione completa (in caso di richiesta accettata):</p>
        <img src="img/WasteTruckRequest_Complete_Accept.png" alt="WasteTruckRequest complete interaction of accepted request" style="width: 800px">


<!---->
        <h4>[<i>Attesa Conferma Committente</i>] Conferma deposito (Evoluzine della gestione degli errori in scarico)</h4>





<!--  --------5--------  -->
    <h3>Analisi <b>TransportTrolley</b></h3>
        <h4>Delega Deposit Action</h4>
            <p>La <i>Deposti Action</i> definita nello Sprint-0 come la sequenza di operazioni:</p>
            <ul>
                <li><b>PickUp</b></li>
                <li><b>Deposit</b></li>
                <li><b>Return Home</b></li>
            </ul>
            <p>Come analizzato nella <a href="#sec-Int-WS-TT">sezione precedente</a> questa viene <u>delegata</u> dal <b>WasteService</b> tramite la richietsa di <i>PickUp</i>.
            Passando anche il parametro di <code>TYPE</code> del materiale, in modo che il <b>TransportTrolley</b>, una volta completato il <i>PickUp</i> possa proseguire autonomamente con la <i>Deposit</i></p>

            <p>Vengono quindi instanziate le variabili: </p>
            <pre><code>
 var ID
 var MaterialType
            </code></pre>
            <ul>
                <li><code>ID</code>: per tenere traccia di quale richiesta si sta eseguendo</li>
                <li><code>MaterialType</code>: per gestire dove scaricare i rifiuti una volta raccolti</li>
            </ul>

            <p>Queste vengono aggiornate ad ogni richiesta <code>pickupReq(ID, TYPE)</code> ricevuta, con i parametri della richiesta:</p>
            <pre><code>
 onMsg(pickupReq : pickupReq(ID, TYPE)){
    [#
        ID = payloadArg(0)
        MaterialType = payloadArg(1)
    #]
    println("\t $name: pickupRequest received! ($ID, $MaterialType)") color blue
 }
            </code></pre>

        <p>La <i>Deposit</i> verrà dunque poi gestita in base al tipo di materiale:</p>
        <pre><code>
 State deposit {
    if[# materialType == "plastic" #]{
        //Goto PlasticBox
        println("\t $name: Going to PlasticBox!") color blue
        ...
    }

    if[# materialType == "glass" #]{
        //Goto GlassBox
        println("\t $name: Going to GlassBox!") color blue
        ...
    }
 }
        </code></pre>







    <h3>5 - Analisi TransportTrolley</h3>
        <p>Il <b>TransportTrolley</b> da requisiti si occuperà di muovere e rappresentare come entità Software il Robot fisico <i>DDR</i>.</p>
        <p>Analizziamo qui dunque il Macro-Problema della logica di movimento.</p>
        <div class="note">
            <ul>
                <li>Delega Deposit Action</li>
                <li>Rappresentazione della posizione nella <i>Service Area</i></li>
                <li>Navigazione</li>
                <li>Astrazione del Movimento per il TransportTrolley</li>
                <li>Richieste Multiple durante l'esecuzione</li>
            <ul>
                <ul>
                    <li>Gestione richieste mentre sta scaricando</li>
                    <li>Problema gestione richieste in movimento (gestire tornare in dietro oppure no?)</li>
                    Farla gestire dalla prossima posizione utile.
                </ul>
                <li>Problema comandi al <i>DDR Robot</i> <b>Sec-6</b></li>
            </ul>
        </div>

        <h4>Rappresentazione della posizione nella <i>Service Area</i></h4>
            <p>Analizzando la problematica le soluzioni indivudate sono 2:</p>
            <ul>
                <li>Rappresentazione tramite <b>Coordinate</b></li>
                <li>Rappresentazione delle sole <b>posizioni salienti</b>: Home, Indoor, PlasticBox, GlassBox.</li>
            </ul>
        <p></p>

        <h5>Vantaggi dell'utilizzo di un sistema basato su coordinate:</h5>
        <p>Un sistema basato su coordinate prevede la divisione di tutta la service Area in una matrice con celle di dimensione <code>RD</code>, ovvero la dimensione del robot.</p>
        <p>Il <i>Robot</i> dovrà quindi eseguire spostamenti di grandezza <code>RD</code> denominabili <i>Step</i>.</p>
        <p>Così facendo la posizine del Robot sarà individuabile in ogni momento come coppia ordinata di numeri. () </p>
        <pre><code>
 pos = (x,y)
        </code></pre>
        <img src="img/ServiceAreaPosition-Coords.png" alt="" style="width: 500px">
        <p>Vantaggi:</p>
        <ul>
            <li>Maggiore flessibilità: Un sistema basato su coordinate offre maggiore flessibilità nel gestire la posizione dei siti.
                Ad esempio, può adattarsi facilmente se i siti non sono più posizionati agli angoli, se il robot deve seguire un percorso ottimale o se ci sono ostacoli nell'area di servizio.</li>
            <li>Potenziale riutilizzo di moduli esistenti: Utilizzando un sistema basato su coordinate, è possibile sfruttare moduli sviluppati precedentemente come mapper e planner,
                evitando la necessità di sviluppare nuove soluzioni da zero.</li>
        </ul>

        <h5>Vantaggi dell'utilizzo di un sistema senza coordinate:</h5>
        <p>La disposizione specifica delle <i>zone salienti</i> e la presenza di un sonar on-board sul robot, permettono la realizzazione senza l'uso di coordinate.<br>
            Il robot può spostarsi all'interno dell'area di servizio lungo le pareti, utilizzando la rilevazione delle collisioni con le pareti per orientarsi.</p>
        <ul>
            <li>Minor complessità e costo inferiore: L'assenza di un sistema basato su coordinate semplifica il design complessivo e riduce i costi associati all'implementazione.</li>
            <li>Maggiore velocità di spostamento e reattività: Senza la necessità di completare passi specifici, un sistema senza coordinate consente movimenti più rapidi e una maggiore reattività ai comandi di arresto durante il movimento in avanti.</li>
            <li> I robot reali potrebbero beneficiare di un sistema senza coordinate, in quanto non richiede l'uso di sistemi di feedback o hardware aggiuntivo per controllare i propri spostamenti in modo più preciso. A differenza di una soluzione basata su coordinate, un sistema basato sulla rilevazione di contatti con le pareti non è soggetto all'accumulo di errori ad ogni passo.</li>
        </ul>
        <img src="img/ServiceAreaPosition-4.png" alt="" style="width: 400px">

        <p>Assunto che: (dallo Sprint-0)</p>
        <ul>
            <li>Il committente non specifica un particolare tipo di rappresentazioni delle posizioni</li>
            <li>Il <i>Robot</i> si muoverà solo sul perimetro della stanza</li>
            <li>La <i>Service Area</i> non contiene ulteriori ostacoli</li>
        </ul>
        <tt>La soluzione scelta è quella di un sistema di rappresentazione <b>senza coordinate</b>. Dati i vantaggi evidenziati.<br>
            Si mappa dunque la posizione tramite le <i>posizioni salienti</i>:
            <pre><code>
 Enum Position = {Indoor, PlasticBox, GlassBox, Home}
            </code></pre>
        </tt>


<!---->
        <h4>Logica di Navigazione</h4>
            <p>Data la scelta di adottare un sistema senza coordinate, nasce il problema della navigazione del <i>Robot</i> tra le 4 posizioni salienti.</p>
            <p>Visti i percorsi effettuabili nello <a>Sprint-0</a></p>
            <img src="" alt="">
            <p>Considerando le posizioni ordinate in senso antiorario: <code>Home, Indoor, PlasticBox, GlassBox</code>.</p>
            <p>L'implementazione per la navigazione ordinata tra queste avverà con la seguente logica:</p>
            <ul>
                <li>Il robot si muove in avanti finché non rileva il muro</li>
                <li>Il robot si ruota di 90° verso sinistra</li>
                <li>Ripetere per la prossima posizione saliente</li>
            </ul>
        <p>Questo ci permette di visitare in ordine le posizioni <code>Home, Indoor, PlasticBox, GlassBox</code>.</p>
<!--TODO        <img src="" alt="">-->



<!---->
        <h4>Astrazione della navigazione per il <b>TransportTrolley</b></h4>
            <p>Date le scelte sulla rappresentazione delle posizioni, il <b>TransportTrolley</b> navigherà solo sulla base delle 4 psizioni salienti:</p>
            <p>Presentiamo varie soluzioni:</p>
            <ol>
                <li>Il <b>TransportTrolley</b> implementerà la logica di moviemento tra le 4 posizioni</li>
                <li>Il <b>TransportTrolley</b> astrarrà dall'implementazione dei percorsi</li>
            </ol>
        <p>Per una più corretta progettazione e implementazione del codice decidiamo di astrarre il componente <b>TransportTrolley</b> dalla logica implementativa della navigazione.</p>

        <p>Il <b>TransportTrolley</b> si occuperà dunque solo di:</p>
        <ul>
            <li><i>Conoscere</i> la posizione in cui si trova</li>
            <li><i>Indicare</i> la posizione da raggiungere</li>
        </ul>

        <tt>
            <p>Per fare ciò si introducono due messaggi che il <b>TransportTrolley</b> invierà con semantica <i>Request/Response</i>:</p>
            <pre><code>
 Request move        :    move(CurrentPos, NewPos)
 Reply   moveDone    :    moveDone(NewPos)
            </code></pre>
        </tt>
        <tt>
            Vista l'astrazione introdotta risulta necessaria l'introduzione di un <b>nuovo componente</b> <i>mediatore</i> tra il <b>TransportTrolley</b> e il <b>BasicRobot22</b>.<br>
            Che enalizzeremo nella <a href="#sec-6">Macro-Sezione Successiva</a>.
            <img src="img/TransportTrolley_BasicRobot_Interaction.png" alt="" style="width: 550px">
        </tt>
        




        <h4>Problema richieste multiple : </h4>
		<p>
		Come da requisiti il <b>TransportTrolley</b> può ricevere più richieste durante l'esecuzione della <i>depositAction</i>. 
		Le richieste possono arrivare in due momenti, quando il <b>DDR Robot</b> è in movimento o quando sta effettuando l'operazione di deposito in uno dei due box.
		Non essendoci vincoli da requisiti, la scelta progettuale che ci è parsa più conveniente è quella di far arrivare il <b>DDR Robot</b> alla prossima posizione anche se 
		quest'ultimo riceve richieste mentre è in movimento.
		Andiamo ora ad analizzare due possibili soluzioni per poter gestire richieste multiple.
		<h5>Soluzione 1: girare indietro</h5>
		<p>
		La prima soluzione da noi proposta è quella di far percorrere il percorso alla rovescia al <b>DDR Robot</b>, ossia di far girare quest'ultimo di 180°. Questa soluzione
		risulta ottimale nel momento in cui il <b>DDR Robot</b> si trova più vicino alla posizione di <b>Indoor</b> rispetto che alla posizione di <b>Home</b>.
		<h5>Soluzione 2: passare per la Home</h5>
		<p>
		La seconda soluzione da noi proposta prevede invece di far completare l'intero percorso al <b>DDR Robot</b> al di là delle richieste multiple o della singola richiesta.
		Attuando questo tipo di soluzione il <b>DDR Robot</b> farà sempre lo stesso percorso, ossia <i>Home</i>-><i>Indoor</i>-><i>PlasticBox</i>-><i>GlassBox</i>-><i>Home</i>.
		</p>
		<tt>
		La scelta tra una soluzione e l'altra non influisce sull'architettura del sistema per le scelte progettuali effettuate, quindi possono essere implementate entrambe
		configurandole a livello applicativo.
		</tt>

        <!--<tt>
            Il <b>WasteService</b> può ricevere e gestire una richiesta alla volta mentre il <b>TransportTrolley</b> è abilitato a gestire più richieste di scarico ed è abilitato
            a fare questo tramite la gestione di una coda. Il <b>WasteService</b> può gestire le richieste mentre il <b>TransportTrolley</b> è ancora occupato a gestire l'azione
            di carico/scarico.

            Vantaggi e Svantaggi di far girare il robot all'indietro (percorso a rovescio o facendolo ritornare alla HOME e ripartire )


            c.	Può ricevere richieste mentre sta scaricando (2 modi)
                    i.	Facendolo girare in dietro vs passa per la home (analizzaimo entrambi e possiamo implementare entrambi, configurabile)
        </tt>-->






	<h3 id="sec-6">6 - Interazione TT e BasicRobot22</h3>
	 <p>Il <b>TransportTrolley</b> si occuperà di far muovere il robot per il carico/scarico dei rifiuti. Per la messa in azione del robot è possibile 
		riutilizzare il software già sviluppato per eseguire il path trovato (unibo.pathexecutor) e quindi il <b>TransportTrolley</b> incaricherà il robot 
		del percorso da compiere mediante il riutilizzo di questo software.
		
		Il <b>TransportTrolley</b> è a conoscenza della posizione iniziale e della destinazione del <b>BasicRobot</b> e manda una Request ad un nuovo componente customizzato <b>CustomPathExecutor</b> e quest'ultimo si 
		occuperà di far arrivare il <b>BasicRobot</b> a destinazione mediante l'invio di messaggi seguendo la logica di spostamento sul perimetro e gestendo le collisioni con le pareti.
		Il <b>CustomPathExecutor</b> sarà in grado di comunicare tramite una Reply al <b>TransportTrolley</b> quando il <b>BasicRobot</b> arriva a destinazione.
		Come già anticipato,andrà aggiunto questo nuovo componente custom nel contesto <i>ctxwasteservice</i> che fa da tramite per l'interazione tra <b>TransportTrolley</b> e <b>BasicRobot</b> e l'architettura risulterà come segue:
		
		<div>
		<img src="" alt="General Architecture with new custom component" style="width: 800px">
		</div>
		
		
		<br>
        <br>
        <br>

<!-- ------------------------------------------------------ -->
<h2>Modello Eseguibile</h2>
        <ul>
            <li>Componenti</li>
            <li>Interfacce (Messaggi scambiati)</li>
            <li>Modello Eseguibile QAK</li>
        </ul>

        <div class="remark" style="background-color: #c3fbe8;">
            <h3>Riassunto situazione attuale:</h3>
            <h4>Architettura logica:</h4>
            <img src="" alt="General Logical Architecture">
            <p style="width: 100%; text-align: right;"><a href="../../Sprint-0/userDocs/img/Legenda.png">Legenda.png</a></p>
            <h4>QAK</h4>
            <a href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Logical_Architecture_QAK/src/Logical_Architecture_Local.qak">Modello del sistema QAK</a> <br>
            <a href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Qak_Models/WasteService.qak">Primo metamodello QAK <i>wasteservice</i></a> <small>(= a sprint0)</small><br>
            <a href="https://github.com/LucaLand/WasteService22-LLA/blob/dev/sprint-0/Sprint-0/Qak_Models/TransportTrolley.qak">Primo metamodello QAK <i>transporttrolley</i></a> <br>


        </div>



<h2>Test-Unit</h2>





<br>
<br>
<br>


<!-- ------------------------------------------------------ -->


</div>


<!-- FOOTER -->
<br><br>
<div style="background-color:rgba(86, 56, 253, 0.9); width:100%; height: 28vw; text-align:left; color:white;">
    <p style="text-align: center; font-size: 12pt;">Studenti: Luca Landolfi, Antonio Franzese, Luca De Risi</p>
    <p style="text-align: center; font-size: 12pt;">Email: luca.landolfi3@studio.unibo.it,  antonio.franzese4@studio.unibo.it, luca.derisi@studio.unibo.it;</p>
    <div style="display: block; margin: 0 15vw;">
        <img src="./img/img_luca.png"   style="float: left; width: 19vw; height: 20vw">
        <img src="./img/img_anto.jpg"   style="float: left; width: 19vw; height: 20vw">
        <img src="./img/img_lude.JPG"   style="float: left; width: 22vw; height: 20vw">
    </div>
</div>

</body>
</html>
